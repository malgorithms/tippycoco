/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ai/ai.ts":
/*!**********************!*\
  !*** ./src/ai/ai.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"aiNames\": () => (/* binding */ aiNames),\n/* harmony export */   \"aiToName\": () => (/* binding */ aiToName),\n/* harmony export */   \"ais\": () => (/* binding */ ais)\n/* harmony export */ });\n/* harmony import */ var _black_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./black-ai */ \"./src/ai/black-ai.ts\");\n/* harmony import */ var _green_ai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./green-ai */ \"./src/ai/green-ai.ts\");\n/* harmony import */ var _purple_ai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./purple-ai */ \"./src/ai/purple-ai.ts\");\n/* harmony import */ var _white_ai__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./white-ai */ \"./src/ai/white-ai.ts\");\n\n\n\n\nconst ais = {\n    Green: _green_ai__WEBPACK_IMPORTED_MODULE_1__._GreenAi,\n    Black: _black_ai__WEBPACK_IMPORTED_MODULE_0__._BlackAi,\n    White: _white_ai__WEBPACK_IMPORTED_MODULE_3__._WhiteAi,\n    Purple: _purple_ai__WEBPACK_IMPORTED_MODULE_2__._PurpleAi,\n};\nconst aiNames = Object.keys(ais);\nfunction aiToName(ai) {\n    for (const k in ais) {\n        const name = k;\n        if (ai instanceof ais[name] || ai === ais[name]) {\n            return name;\n        }\n    }\n    console.log(ai);\n    throw new Error('Unknown Ai.');\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/ai.ts?");

/***/ }),

/***/ "./src/ai/base.ts":
/*!************************!*\
  !*** ./src/ai/base.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AiBase\": () => (/* binding */ AiBase)\n/* harmony export */ });\n/* harmony import */ var _future_prediction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../future-prediction */ \"./src/future-prediction.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n\n\n\nclass AiBase {\n    constructor() {\n        this._lastMoveLeft = 0;\n        this._lastMoveRight = 0;\n        this._lastJump = 0;\n    }\n    /**\n     * @returns milliseconds since I've last jumped, or Infinity if never\n     */\n    msSinceMyLastJump(o) {\n        return this._lastJump ? o.gameTime.totalGameTime.totalMilliseconds - this._lastJump : Infinity;\n    }\n    /**\n     * @returns milliseconds since I've last moved left, or Infinity if never\n     */\n    msSinceMyLastMoveLeft(o) {\n        return this._lastMoveLeft ? o.gameTime.totalGameTime.totalMilliseconds - this._lastMoveLeft : Infinity;\n    }\n    /**\n     * @returns milliseconds since I've last moved right, or Infinity if never\n     */\n    msSinceMyLastMoveRight(o) {\n        return this._lastMoveRight ? o.gameTime.totalGameTime.totalMilliseconds - this._lastMoveRight : Infinity;\n    }\n    getNextBallEnteringMyJumpRange(o) {\n        const myPlayerSide = o.myPlayerSide;\n        let result = (0,_future_prediction__WEBPACK_IMPORTED_MODULE_0__.unknownState)();\n        for (const pred of o.ballPredictions) {\n            const lookup = pred.ballEnteringJumpRange(myPlayerSide);\n            if (!lookup)\n                throw new Error('failed to lookup');\n            if (!(result === null || result === void 0 ? void 0 : result.isKnown) || lookup.time < result.time) {\n                result = lookup;\n            }\n        }\n        return this.futureStateToBall(result);\n    }\n    getNextBallHittingOnMySide(o) {\n        const myPlayerSide = o.myPlayerSide;\n        const net = o.net;\n        const result = (0,_future_prediction__WEBPACK_IMPORTED_MODULE_0__.unknownState)();\n        const amLeft = myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_2__.PlayerSide.Left;\n        for (const p of o.ballPredictions) {\n            const hittingGround = p.ballHittingGround;\n            if ((amLeft && hittingGround.pos.x > net.center.x) || (!amLeft && hittingGround.pos.x < net.center.x)) {\n                continue;\n            }\n            if (hittingGround.isKnown && hittingGround.time < result.time) {\n                result.isKnown = true;\n                result.time = hittingGround.time;\n                result.pos = hittingGround.pos;\n            }\n        }\n        return this.futureStateToBall(result);\n    }\n    // This is a bit prettier for writing the inherited classes, since\n    // there is no nonsense data when nothing known\n    futureStateToBall(fs) {\n        if (fs.isKnown)\n            return { pos: fs.pos, time: fs.time };\n        return null;\n    }\n    goToSize(o, fractionOfWayFromSmallToLarge) {\n        const gameTime = o.gameTime;\n        const me = o.me;\n        const dt = gameTime.elapsedGameTime.totalMilliseconds / 1000;\n        const minD = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.minDiameter;\n        const maxD = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.maxDiameter;\n        const targetSize = minD + fractionOfWayFromSmallToLarge * (maxD - minD);\n        if (me.physics.diameter < targetSize)\n            me.grow(dt, _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.growSpeed);\n        else if (me.physics.diameter > targetSize)\n            me.grow(dt, -_tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.growSpeed);\n    }\n    moveLeft(o) {\n        this._lastMoveLeft = o.gameTime.totalGameTime.totalMilliseconds;\n        o.me.moveLeft();\n    }\n    moveRight(o) {\n        this._lastMoveRight = o.gameTime.totalGameTime.totalMilliseconds;\n        o.me.moveRight();\n    }\n    amIAboveTheNet(o) {\n        const px = o.me.physics.center.x;\n        const net = o.net;\n        return px > net.center.x - net.width / 2 && px < net.center.x + net.width / 2;\n    }\n    amIOnTheWrongSide(o) {\n        const net = o.net;\n        const px = o.me.physics.center.x;\n        if (o.myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_2__.PlayerSide.Left)\n            return px > net.center.x + net.width / 2;\n        else\n            return px < net.center.x - net.width / 2;\n    }\n    /**\n     *\n     * @param o\n     * @param fractionOfMaxVelocity - -1...1 how close to max speed\n     */\n    moveRationally(o, fractionOfMaxVelocity) {\n        if (fractionOfMaxVelocity < 0)\n            this._lastMoveLeft = o.gameTime.totalGameTime.totalMilliseconds;\n        else if (fractionOfMaxVelocity > 0)\n            this._lastMoveRight = o.gameTime.totalGameTime.totalMilliseconds;\n        o.me.moveRationally(fractionOfMaxVelocity);\n    }\n    /**\n     * stop moving left/right\n     */\n    stopMoving(o) {\n        o.me.moveRationally(0);\n    }\n    /**\n     * jumps but only if you're in position to\n     * @param gameTime for storing when you last jumped\n     * @param me myself\n     */\n    jumpIfPossible(o) {\n        this._lastJump = o.gameTime.totalGameTime.totalMilliseconds;\n        o.me.jump();\n    }\n    isInJumpingPosition(player) {\n        return player.isInJumpPosition;\n    }\n    /**\n     * this goto tries to be a little smoother, acting with rational speed as it's close to it's destination\n     */\n    tryToGetToX(o, x, sec, reactionTimeMs) {\n        if (sec <= 0)\n            return;\n        const cx = o.me.physics.center.x;\n        const dx = x - cx;\n        const speedNeeded = dx / sec;\n        const speed = speedNeeded * 2; // we go faster than we need to\n        let scale = speed / o.me.maxVel.x;\n        if (scale > 1)\n            scale = 1;\n        if (scale < -1)\n            scale = -1;\n        if (scale > 0 && this.msSinceMyLastMoveLeft(o) > reactionTimeMs) {\n            this.moveRationally(o, scale);\n        }\n        else if (scale < 0 && this.msSinceMyLastMoveRight(o) > reactionTimeMs) {\n            this.moveRationally(o, scale);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/base.ts?");

/***/ }),

/***/ "./src/ai/black-ai.ts":
/*!****************************!*\
  !*** ./src/ai/black-ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_BlackAi\": () => (/* binding */ BlackAi)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./src/ai/base.ts\");\n/* harmony import */ var _white_ai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./white-ai */ \"./src/ai/white-ai.ts\");\n\n\n\nconst REACTION_TIME_MS = 20;\n//\n// TODO: replace that this is just using a green AI.\n//\nclass BlackAi extends _base__WEBPACK_IMPORTED_MODULE_1__.AiBase {\n    constructor() {\n        super();\n        this.hiddenWhiteBrain = new _white_ai__WEBPACK_IMPORTED_MODULE_2__._WhiteAi();\n    }\n    think(o) {\n        if ((o.p0Score + o.p1Score) % 3 == 0 && Math.sin(o.accumulatedPointSeconds / 3) < 0) {\n            this.hiddenWhiteBrain.think(o);\n            return;\n        }\n        const me = o.me;\n        // Just jump sometimes\n        if (o.accumulatedPointSeconds < 1) {\n            this.jumpIfPossible(o);\n        }\n        this.goToSize(o, 0.9);\n        if (o.accumulatedPointSeconds < 1.0)\n            return;\n        let stateToWatch = o.ballPredictions[0].ballEnteringJumpRange(o.myPlayerSide);\n        const amLeft = o.myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left;\n        if (!stateToWatch.isKnown)\n            stateToWatch = o.ballPredictions[0].ballHittingGround;\n        if (stateToWatch.isKnown)\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        // What to do if we have no idea\n        if (!stateToWatch.isKnown) {\n            if (me.physics.center.x < o.net.center.x + o.net.width / 2 + (2 * me.physics.diameter) / 3)\n                this.moveRight(o);\n            else if (me.physics.center.x > 1.0 - (2 * me.physics.diameter) / 3)\n                this.moveLeft(o);\n            else\n                this.stopMoving(o);\n            return;\n        }\n        // Let's add some randomness for stupidity\n        stateToWatch.pos.x += (o.balls[0].physics.diameter * Math.sin(o.gameTime.elapsedGameTime.totalSeconds)) / 6;\n        stateToWatch.pos.y += (o.balls[0].physics.diameter * Math.sin(o.gameTime.elapsedGameTime.totalSeconds)) / 6;\n        // At this point we know we have a state to watch\n        if (!amLeft && me.physics.center.x < o.net.center.x - o.net.width / 2) {\n            // keep me on my side of net\n            this.jumpIfPossible(o);\n            this.moveRight(o);\n        }\n        else {\n            this.tryToGetToX(o, stateToWatch.pos.x, stateToWatch.time, REACTION_TIME_MS);\n        }\n        const timeTillJump = me.getTimeToJumpToHeight(o.gameGravity.y, stateToWatch.pos.y);\n        // Only jump sometimes\n        if (stateToWatch.time < timeTillJump && o.gameTime.totalGameTime.totalSeconds % 50 != 0) {\n            this.jumpIfPossible(o);\n        }\n    }\n}\n// import from ai.ts not here, to use\n\n\n\n//# sourceURL=webpack:///./src/ai/black-ai.ts?");

/***/ }),

/***/ "./src/ai/green-ai.ts":
/*!****************************!*\
  !*** ./src/ai/green-ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_GreenAi\": () => (/* binding */ GreenAi)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/ai/base.ts\");\n\nconst PREDICT_SEC = 0.4; // seconds in the future green will see\nconst REACTION_TIME_MS = 300; // I can't change wiggle direction faster than this\n/**\n *  This AI serves as a good simple example how to write a TCFTG player.\n *  It's not too bright but the code is simple and clean.\n */\nclass GreenAi extends _base__WEBPACK_IMPORTED_MODULE_0__.AiBase {\n    constructor() {\n        super();\n    }\n    /**\n     * `think` is the function you must implement in your AI. it takes a general\n     * object `o` that has a bunch of game state. Your think function is called many\n     * times per second. It doesn't return anything. Instead, you send movement\n     * commands such as `this.jumpIfPossible(o)` or `this.moveLeft(o)`\n     * @param o\n     */\n    think(o) {\n        // I just jump sometimes\n        if (o.accumulatedPointSeconds < 1)\n            this.jumpIfPossible(o);\n        // And hang out at 90% size\n        this.goToSize(o, 0.9);\n        // I try not to move otherwise the first second of a point\n        if (o.accumulatedPointSeconds < 1)\n            return;\n        // Ok, now I need a point of interest. First thing I look for is\n        // a ball entering my jump range. If there isn't one coming, even worse,\n        // maybe it is on its way to hit on my side.\n        const target = this.getNextBallEnteringMyJumpRange(o) || this.getNextBallHittingOnMySide(o);\n        if (!target) {\n            this.moveRationally(o, 0.1); // let's just move right at 10% speed\n            this.jumpIfPossible(o);\n        }\n        else {\n            // I'll try to stay a bit to the right of the position\n            target.pos.x += -0.16 * o.me.physics.diameter;\n            if (target.time < PREDICT_SEC) {\n                // Let's add some randomness for stupidity, but have that randomness a function of the\n                // current time, so it's not flickering all over the place.\n                const err = Math.sin(o.gameTime.totalGameTime.totalSeconds);\n                target.pos.x += (o.balls[0].physics.diameter * err) / 1.5;\n                target.pos.y += (o.balls[0].physics.diameter * err) / 1.5;\n                // At this point we know we have a state to watch\n                // keep me on my side of net\n                if (this.amIAboveTheNet(o) || this.amIOnTheWrongSide(o)) {\n                    this.jumpIfPossible(o);\n                    this.moveRight(o);\n                }\n                else {\n                    // the base class has this helper that uses a rational move speed to\n                    // try to get to a spot by a certain time.\n                    this.tryToGetToX(o, target.pos.x, target.time, REACTION_TIME_MS);\n                }\n                // Remaining question is...do I jump?\n                const seconds = Math.floor(o.gameTime.totalGameTime.totalSeconds);\n                const isOddSecond = seconds % 2;\n                const timeErr = 0.3 * Math.sin(o.accumulatedPointSeconds);\n                const timeTillJump = o.me.getTimeToJumpToHeight(o.gameGravity.y, target.pos.y) + timeErr;\n                if (target.time < timeTillJump && isOddSecond)\n                    this.jumpIfPossible(o);\n            }\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/green-ai.ts?");

/***/ }),

/***/ "./src/ai/purple-ai.ts":
/*!*****************************!*\
  !*** ./src/ai/purple-ai.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_PurpleAi\": () => (/* binding */ PurpleAi)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/ai/base.ts\");\n\nconst REACTION_TIME_MS = 25; // seconds\nclass PurpleAi extends _base__WEBPACK_IMPORTED_MODULE_0__.AiBase {\n    constructor() {\n        super();\n    }\n    timeTillICanReachLanding(o) {\n        const landing = this.getNextBallHittingOnMySide(o);\n        if (!landing)\n            return Infinity;\n        return Math.abs(landing.pos.x - o.me.physics.center.x) / o.me.maxVel.x;\n    }\n    think(o) {\n        const me = o.me;\n        if (o.accumulatedPointSeconds < 1.0)\n            return;\n        // Gonna shrink as small as possible\n        this.goToSize(o, 0.25);\n        if (o.balls[0].physics.vel.x == 0 && o.balls[0].physics.center.x == 0.25) {\n            // could have it do some kind of taunting here\n            return;\n        }\n        const enteringMyRange = this.getNextBallEnteringMyJumpRange(o);\n        const landingOnMySide = this.getNextBallHittingOnMySide(o);\n        const timeToGetThere = this.timeTillICanReachLanding(o);\n        let stateToWatch = null;\n        if (landingOnMySide && (!enteringMyRange || landingOnMySide.time < timeToGetThere + 0.1)) {\n            stateToWatch = landingOnMySide;\n            stateToWatch.pos.x -= 0.16 * me.physics.diameter;\n        }\n        else if (enteringMyRange) {\n            stateToWatch = enteringMyRange;\n            stateToWatch.pos.x -= 0.16 * me.physics.diameter;\n        }\n        for (const b of o.balls) {\n            const deltaX = b.physics.center.x - o.me.physics.center.x;\n            const deltaY = b.physics.center.y - o.me.physics.center.y;\n            if (deltaX > -0.05 && deltaX < 0 && deltaY < o.me.physics.diameter * 2)\n                this.jumpIfPossible(o);\n        }\n        // What to do if we have no idea\n        if (!stateToWatch) {\n            // Half the time go to the top of the net. The other half, do other crap.\n            if ((o.accumulatedPointSeconds / 10) % 2 == 1) {\n                if (me.physics.center.x > o.net.center.x + o.net.width / 2) {\n                    this.jumpIfPossible(o);\n                    this.moveLeft(o);\n                }\n                else if (me.physics.center.x < o.net.center.x - o.net.width / 2) {\n                    this.jumpIfPossible(o);\n                    this.moveRight(o);\n                }\n                else {\n                    const speed = (o.net.center.x - me.physics.center.x) / (o.net.width / 2);\n                    this.moveRationally(o, speed);\n                }\n            }\n            else {\n                if (me.physics.center.x < o.net.center.x + o.net.width / 2 + (2 * me.physics.diameter) / 3)\n                    this.moveRight(o);\n                else if (me.physics.center.x > 1.0 - (2 * me.physics.diameter) / 3)\n                    this.moveLeft(o);\n                else {\n                    //console.log(1)\n                    this.stopMoving(o);\n                }\n            }\n            return;\n        }\n        // At this point we know we have a state to watch\n        if (me.physics.center.x < o.net.center.x - o.net.width / 2) {\n            // keep me on my side of net\n            this.jumpIfPossible(o);\n            this.moveRight(o);\n        }\n        else {\n            this.tryToGetToX(o, stateToWatch.pos.x, stateToWatch.time, REACTION_TIME_MS);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/purple-ai.ts?");

/***/ }),

/***/ "./src/ai/white-ai.ts":
/*!****************************!*\
  !*** ./src/ai/white-ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_WhiteAi\": () => (/* binding */ WhiteAi)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./src/ai/base.ts\");\n\n\n// not jumping right at the start of a point prevents WhiteAi from\n// getting aced with an underbelly serve\nconst NO_JUMP_BEFORE = 1.5;\nconst REACTION_TIME_MS = 25;\nclass WhiteAi extends _base__WEBPACK_IMPORTED_MODULE_1__.AiBase {\n    constructor() {\n        super();\n    }\n    j(o) {\n        if (o.accumulatedPointSeconds > NO_JUMP_BEFORE)\n            this.jumpIfPossible(o);\n    }\n    timeTillICanReachLanding(o) {\n        const landing = this.getNextBallHittingOnMySide(o);\n        if (!landing)\n            return Infinity;\n        return Math.abs(landing.pos.x - o.me.physics.center.x) / o.me.maxVel.x;\n    }\n    think(o) {\n        const me = o.me;\n        const opponent = o.opponent;\n        this.goToSize(o, 0.7);\n        if (o.accumulatedPointSeconds < 1.0)\n            return;\n        else {\n            this.goToSize(o, 0);\n        }\n        // PERFORM A MIRROR MANEUVER\n        if (o.accumulatedPointSeconds < 0.5) {\n            let offset = (me.physics.center.x - o.net.center.x - (o.net.center.x - opponent.physics.center.x)) / me.physics.diameter;\n            if (offset > 1.0)\n                offset = 1.0;\n            if (offset < -1.0)\n                offset = 1.0;\n            this.moveRationally(o, -offset);\n            if (opponent.physics.center.y > me.physics.center.y) {\n                this.j(o);\n            }\n            return;\n        }\n        if (o.balls[0].physics.vel.x == 0 && o.balls[0].physics.center.x == 0.25) {\n            // Don't move if opponent hasn't.\n            return;\n        }\n        let stateToWatch = null;\n        const amLeft = o.myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left;\n        const enteringMyRange = this.getNextBallEnteringMyJumpRange(o);\n        const landingOnMySide = this.getNextBallHittingOnMySide(o);\n        const timeToReach = this.timeTillICanReachLanding(o);\n        if (landingOnMySide && (!enteringMyRange || landingOnMySide.time < timeToReach + 0.1)) {\n            stateToWatch = landingOnMySide;\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        }\n        else if (enteringMyRange) {\n            stateToWatch = enteringMyRange;\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        }\n        // What to do if we have no idea\n        if (!stateToWatch) {\n            // Half the time go to the top of the net. The other half, do other crap.\n            if ((Math.floor(o.accumulatedPointSeconds) / 10) % 2 == 1) {\n                if (me.physics.center.x > o.net.center.x + o.net.width / 2) {\n                    this.j(o);\n                    this.moveLeft(o);\n                }\n                else if (me.physics.center.x < o.net.center.x - o.net.width / 2) {\n                    this.j(o);\n                    this.moveRight(o);\n                }\n                else {\n                    const speed = (o.net.center.x - me.physics.center.x) / (o.net.width / 2);\n                    this.moveRationally(o, speed);\n                }\n            }\n            else {\n                if (me.physics.center.x < o.net.center.x + o.net.width / 2 + (2 * me.physics.diameter) / 3)\n                    this.moveRight(o);\n                else if (me.physics.center.x > 1.0 - (2 * me.physics.diameter) / 3)\n                    this.moveLeft(o);\n                else\n                    this.stopMoving(o);\n            }\n            return;\n        }\n        // At this point we know we have a state to watch\n        if (!amLeft && me.physics.center.x < o.net.center.x - o.net.width / 2) {\n            // keep me on my side of net\n            this.j(o);\n            this.moveRight(o);\n        }\n        else {\n            this.tryToGetToX(o, stateToWatch.pos.x, stateToWatch.time, REACTION_TIME_MS);\n        }\n        const timeTillJump = me.getTimeToJumpToHeight(o.gameGravity.y, stateToWatch.pos.y);\n        // When is it safe to jump?\n        //1. when there's no known landing\n        if (stateToWatch.time < timeTillJump && !landingOnMySide) {\n            this.j(o);\n        }\n        //2. when there's 1 known landing\n        let count = 0;\n        for (const f of o.ballPredictions) {\n            if (f.ballHittingGround.isKnown) {\n                count++;\n            }\n        }\n        if (count <= 1 && stateToWatch.time < timeTillJump) {\n            this.j(o);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/white-ai.ts?");

/***/ }),

/***/ "./src/atmosphere.ts":
/*!***************************!*\
  !*** ./src/atmosphere.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Atmosphere\": () => (/* binding */ Atmosphere)\n/* harmony export */ });\n/* harmony import */ var _ai_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ai/ai */ \"./src/ai/ai.ts\");\n/* harmony import */ var _cloud__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cloud */ \"./src/cloud.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\n\n\n\nclass Atmosphere {\n    constructor(display, canvasManager) {\n        this.numClouds = _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].cloud.num;\n        this.clouds = new Array();\n        this.activeSkies = new Array();\n        this.sunnyCloudTextures = new Array(); // has a 1-1 relationship with DarkCloudTextures list\n        this.darkCloudTextures = new Array(); // has a 1-1 relationship with SunnyCloudTextures list\n        this.display = display;\n        this.canvasManager = canvasManager;\n    }\n    get canvasWidth() {\n        return this.canvasManager.width;\n    }\n    get canvasHeight() {\n        return this.canvasManager.height;\n    }\n    getFractionTransitioned(i) {\n        const now = Date.now();\n        if (this.activeSkies.length <= 1)\n            return 1;\n        const currSky = this.activeSkies[i];\n        const elapsed = now - currSky.whenSpawned;\n        if (elapsed >= _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].atmosphere.skyTransitionMs)\n            return 1;\n        return elapsed / _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].atmosphere.skyTransitionMs;\n    }\n    get sunniness() {\n        if (this.activeSkies.length === 0)\n            return 1;\n        if (this.activeSkies.length === 1) {\n            return this.activeSkies[0].sunniness;\n        }\n        const f = this.getFractionTransitioned(this.activeSkies.length - 1);\n        const currSky = this.activeSkies[this.activeSkies.length - 1];\n        const prevSky = this.activeSkies[this.activeSkies.length - 2];\n        return currSky.sunniness * f + prevSky.sunniness * (1 - f);\n    }\n    skyForOpponent(opp) {\n        const ai = opp.ai;\n        if (opp.species === _player__WEBPACK_IMPORTED_MODULE_2__.PlayerSpecies.Human || !ai) {\n            return {\n                sunny: this.display.getTexture('sunnyBackgroundBlue'),\n                dark: this.display.getTexture('darkBackground'),\n            };\n        }\n        const sunnyTextures = {\n            Green: 'sunnyBackgroundGreen',\n            Black: 'sunnyBackgroundBlack',\n            White: 'sunnyBackgroundFire',\n            Purple: 'sunnyBackgroundPurplish',\n        };\n        const darkTextures = {\n            Green: 'darkBackground',\n            Black: 'darkBackground',\n            White: 'darkBackground',\n            Purple: 'darkBackground',\n        };\n        const aiName = (0,_ai_ai__WEBPACK_IMPORTED_MODULE_0__.aiToName)(ai);\n        return {\n            sunny: this.display.getTexture(sunnyTextures[aiName]),\n            dark: this.display.getTexture(darkTextures[aiName]),\n        };\n    }\n    changeSkyForOpponent(opp, sunniness) {\n        const textures = this.skyForOpponent(opp);\n        if (sunniness === 1)\n            this.changeSky(textures.sunny, 1);\n        else\n            this.changeSky(textures.dark, 0);\n    }\n    changeSky(texture, sunniess) {\n        this.activeSkies.push({\n            texture,\n            whenSpawned: Date.now(),\n            sunniness: sunniess,\n        });\n        if (this.activeSkies.length > _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].atmosphere.maxSkies) {\n            throw new Error('too many skies!');\n        }\n    }\n    pruneAncientSkies() {\n        const freshest = this.activeSkies[this.activeSkies.length - 1];\n        const deleteOldAfter = freshest.whenSpawned + _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].atmosphere.skyTransitionMs;\n        if (Date.now() > deleteOldAfter) {\n            this.activeSkies = [freshest];\n        }\n    }\n    addCloudTextures(sunnyTexture, darkTexture) {\n        this.sunnyCloudTextures.push(sunnyTexture);\n        this.darkCloudTextures.push(darkTexture);\n    }\n    draw(sb) {\n        this.pruneAncientSkies();\n        const view = this.canvasManager.viewableRegion;\n        const bottomOfSkyRight = { x: view.x2, y: _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].net.center.y - _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].net.height / 2 };\n        const ctr = _utils__WEBPACK_IMPORTED_MODULE_4__.vec.avg({ x: view.x1, y: view.y2 }, bottomOfSkyRight);\n        const dims = {\n            w: bottomOfSkyRight.x - view.x1 + 0.1,\n            h: view.y2 - bottomOfSkyRight.y + 0.1,\n        };\n        const numSkies = this.activeSkies.length;\n        for (let i = 0; i < numSkies; i++) {\n            const frac = this.getFractionTransitioned(i);\n            const sky = this.activeSkies[i];\n            const alpha = frac;\n            sb.drawTextureCentered(sky.texture, ctr, dims, 0, alpha);\n        }\n        const nightMoonHeight = view.y2 * _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].moon.nightHeightFrac;\n        const dayMoonHeight = view.y1;\n        const moonHeight = nightMoonHeight - Math.sqrt(this.sunniness) * (nightMoonHeight - dayMoonHeight);\n        const moonLoc = {\n            x: ctr.x + (1 - this.sunniness) * (view.x2 - ctr.x) * _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].moon.widthFrac,\n            y: moonHeight,\n        };\n        const moonTexture = this.display.getTexture('moon');\n        const moonDims = sb.autoDim(0.1, moonTexture);\n        sb.drawTextureCentered(moonTexture, moonLoc, moonDims, 0, 1);\n        for (const c of this.clouds) {\n            sb.drawTextureCentered(c.sunnyTexture, c.pos, sb.autoDim(c.width, c.sunnyTexture), 0, this.sunniness);\n            sb.drawTextureCentered(c.darkTexture, c.pos, sb.autoDim(c.width, c.darkTexture), 0, 1 - this.sunniness);\n        }\n    }\n    step(dt) {\n        for (const c of this.clouds) {\n            c.step(dt);\n        }\n    }\n    fillClouds() {\n        const t = _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n        const vMin = t.cloud.minVel;\n        const vMax = t.cloud.maxVel;\n        for (let i = 0; i < this.numClouds; i++) {\n            const sunny = this.sunnyCloudTextures[i % this.sunnyCloudTextures.length];\n            const dark = this.darkCloudTextures[i % this.darkCloudTextures.length];\n            const vx = vMax.x + Math.random() * (vMax.x - vMin.x);\n            const vy = vMin.y + Math.random() * (vMax.y - vMin.y);\n            const vel = { x: vx, y: vy };\n            const width = sunny.width / 1000;\n            const rect = {\n                x1: t.leftWall.center.x - 1.5,\n                x2: t.rightWall.center.x + 1.5,\n                y1: t.leftWall.center.y - t.leftWall.height / 2,\n                y2: t.rightWall.center.y + t.rightWall.height / 2,\n            };\n            this.clouds.push(new _cloud__WEBPACK_IMPORTED_MODULE_1__.Cloud(rect, sunny, dark, vel, { x: 0, y: 0 }, width));\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/atmosphere.ts?");

/***/ }),

/***/ "./src/ball.ts":
/*!*********************!*\
  !*** ./src/ball.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ball\": () => (/* binding */ Ball)\n/* harmony export */ });\n/* harmony import */ var _circular_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circular-object */ \"./src/circular-object.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\n\nclass Ball {\n    constructor(center, vel, diameter, mass, maxSpeed, orientation, angularVel) {\n        this.physics = new _circular_object__WEBPACK_IMPORTED_MODULE_0__.CircularObject(center, vel, diameter, mass, orientation, angularVel, 1.0, true, _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].physics.ballSpinElasticityOffFrictionPoints, _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].physics.ballSpinVelocityBumpOffFrictionPoints);\n        this.maxSpeed = maxSpeed;\n    }\n    deepCopy() {\n        return new Ball(_utils__WEBPACK_IMPORTED_MODULE_2__.vec.copy(this.physics.center), _utils__WEBPACK_IMPORTED_MODULE_2__.vec.copy(this.physics.vel), this.physics.diameter, this.physics.mass, this.maxSpeed, this.physics.orientation, this.physics.angularVel);\n    }\n    trimSpeedIfNecessary() {\n        const v = this.physics.vel;\n        if (_utils__WEBPACK_IMPORTED_MODULE_2__.vec.lenSq(v) > this.maxSpeed * this.maxSpeed) {\n            this.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.scale(_utils__WEBPACK_IMPORTED_MODULE_2__.vec.normalized(v), this.maxSpeed);\n        }\n    }\n    stepVelocity(dt, gravity, trimSpeedIfNecessary) {\n        const shift = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.scale(gravity, dt * this.physics.gravityMultiplier);\n        this.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.add(this.physics.vel, shift);\n        if (trimSpeedIfNecessary)\n            this.trimSpeedIfNecessary();\n        this.physics.angularVel -= this.physics.angularVel * dt * _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].physics.ballAngularFriction;\n    }\n    stepPositionAndOrientation(dt) {\n        const centerShift = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.scale(this.physics.vel, dt);\n        this.physics.center = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.add(this.physics.center, centerShift);\n        this.physics.orientation += dt * this.physics.angularVel;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ball.ts?");

/***/ }),

/***/ "./src/canvas-manager.ts":
/*!*******************************!*\
  !*** ./src/canvas-manager.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasManager\": () => (/* binding */ CanvasManager)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\n\nclass CanvasManager {\n    constructor(parentEl) {\n        this.center = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].display.zoomCenter;\n        this._currViewRegion = { x1: -Infinity, x2: Infinity, y1: -Infinity, y2: Infinity };\n        this._currOnePixel = 1;\n        this._currInverseTransform = new DOMMatrix();\n        this._zoomScale = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].display.zoomScale.start;\n        this.parentEl = parentEl;\n    }\n    initialDraw() {\n        this.generateCanvas();\n        this.recalcCtxTransform();\n    }\n    recalcCtxTransform() {\n        const cw = this.canvas.width;\n        const ch = this.canvas.height;\n        const unitScale = Math.min(ch / 2, cw / 2);\n        this.ctx.resetTransform();\n        this.ctx.transform(1, 0, 0, -1, 0, ch); // flip y-axis\n        this.ctx.translate(cw / 2, ch / 2); // re-center to middle\n        this.ctx.scale(unitScale, unitScale); // scale to unit\n        this.ctx.translate(-this.center.x / this.zoomScale, -this.center.y / this.zoomScale); // now shift to desired center\n        this.ctx.scale(1 / this.zoomScale, 1 / this.zoomScale); // scale from there\n        const topLeft = this.pixelToCanvasPos({ x: 0, y: 0 });\n        const bottomRight = this.pixelToCanvasPos({ x: this.width, y: this.height });\n        this._currViewRegion = { x1: topLeft.x, x2: bottomRight.x, y1: bottomRight.y, y2: topLeft.y };\n        this._currOnePixel = this.pixelToCanvasPos({ x: 1, y: 1 }).x - this.pixelToCanvasPos({ x: 0, y: 0 }).x;\n        this._currInverseTransform = this.ctx.getTransform().inverse();\n    }\n    get viewableRegion() {\n        return this._currViewRegion;\n    }\n    get onePixel() {\n        return this._currOnePixel;\n    }\n    get zoomScale() {\n        return this._zoomScale;\n    }\n    get ctx() {\n        return this._ctx;\n    }\n    get width() {\n        return this.canvas.width;\n    }\n    get height() {\n        return this.canvas.height;\n    }\n    clearCanvas() {\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.restore();\n    }\n    generateCanvas() {\n        this.parentEl.innerHTML = '';\n        this.canvas = document.createElement('canvas');\n        this.canvas.className = 'game-canvas';\n        this.parentEl.append(this.canvas);\n        this._ctx = this.canvas.getContext('2d');\n        this.canvas.style.opacity = '1.0';\n        this.setCanvasDims();\n        window.addEventListener('resize', () => {\n            this.onWindowResize();\n        });\n    }\n    setCanvasDims() {\n        const c = this.canvas;\n        const w = this.parentEl.offsetWidth;\n        const h = this.parentEl.offsetHeight;\n        c.width = w * _constants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dpr;\n        c.height = h * _constants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dpr;\n        c.style.width = `${w}px`;\n        c.style.height = `${h}px`;\n        this.recalcCtxTransform();\n    }\n    onWindowResize() {\n        this.setCanvasDims();\n        this.recalcCtxTransform();\n    }\n    pixelToCanvasPos(p) {\n        return _utils__WEBPACK_IMPORTED_MODULE_2__.vec.transform(p, this._currInverseTransform);\n    }\n    canvasToPixelPos(p) {\n        return _utils__WEBPACK_IMPORTED_MODULE_2__.vec.transform(p, this.ctx.getTransform());\n    }\n    pixelWidth(pixels) {\n        return this._currOnePixel * pixels;\n    }\n    adjustZoomLevel(maxBallHeight, dt) {\n        const cfg = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].display.zoomScale;\n        let idealZoomLevel = cfg.ballHeightMult * maxBallHeight;\n        if (idealZoomLevel > cfg.max)\n            idealZoomLevel = cfg.max;\n        else if (idealZoomLevel < cfg.min)\n            idealZoomLevel = cfg.min;\n        this._zoomScale += (idealZoomLevel - this.zoomScale) * dt * cfg.springConstant;\n        this.recalcCtxTransform();\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/canvas-manager.ts?");

/***/ }),

/***/ "./src/circular-object.ts":
/*!********************************!*\
  !*** ./src/circular-object.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CircularObject\": () => (/* binding */ CircularObject)\n/* harmony export */ });\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\nclass CircularObject {\n    constructor(center, vel, diameter, mass, orientation, angularVel, gravityMultiplier, canSpin, spinElasticityOffFrictionPoints, spinBumpOffFrictionPoints) {\n        this.center = center;\n        this._angularVel = angularVel;\n        this.vel = vel;\n        this.diameter = diameter;\n        this.orientation = orientation;\n        this.mass = mass;\n        this.gravityMultiplier = gravityMultiplier;\n        this.canSpin = canSpin;\n        this.spinBumpOffFrictionPoints = spinBumpOffFrictionPoints;\n        this.spinElasticityOffFrictionPoints = spinElasticityOffFrictionPoints;\n    }\n    get radius() {\n        return this.diameter / 2;\n    }\n    get angularVel() {\n        if (!this.canSpin)\n            return 0;\n        return this._angularVel;\n    }\n    set angularVel(x) {\n        const vMax = _tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"].physics.maxAngVel;\n        if (!this.canSpin)\n            this._angularVel = 0;\n        else\n            this._angularVel = Math.max(-vMax, Math.min(x, vMax));\n    }\n    distanceToRadians(dist) {\n        return dist / this.radius;\n    }\n    /**\n     * if passed the center of the circle, this would just return the velocity of the ball\n     * but if passed something on the surface, say the top of the ball's location in world coords,\n     * it would return the velocity of the ball + adjustment for angular speed of the point\n     * on the ball there.\n     * @param relPoint\n     */\n    getAtomVelocityAtWorldPoint(worldPoint, isSimulation) {\n        if (worldPoint.x === this.center.x && worldPoint.y === this.center.y) {\n            throw new Error(`Why are we calculating getAtomVelocity at circle's center?`);\n        }\n        else {\n            const dP = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(worldPoint, this.center);\n            const normalTowardsPoint = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.normalized(dP);\n            // this is the direction the point we're considering is heading, dur to the spin\n            const dirDueToSpin = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.rotated90Ccw(normalTowardsPoint);\n            const speedDueToSpin = this.angularVel * _utils__WEBPACK_IMPORTED_MODULE_1__.vec.len(dP);\n            const velDueToSpin = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(dirDueToSpin, speedDueToSpin);\n            const totalVel = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.add(velDueToSpin, this.vel);\n            const totalSpeedInSpinDir = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.dotProduct(totalVel, dirDueToSpin);\n            const totalAngularVel = this.distanceToRadians(totalSpeedInSpinDir);\n            //if (!isSimulation) {\n            //  console.log(`atom velocity:\n            //            ball center: ${this.center.x.toFixed(3)},${this.center.y.toFixed(3)}\n            //               ball vel: ${this.vel.x.toFixed(2)},${this.vel.y.toFixed(2)}\n            //            ball angVel: ${this._angularVel}\n            //            world point: ${worldPoint.x.toFixed(2)},${worldPoint.y.toFixed(2)}\n            //              rel point: ${dP.x.toFixed(2)},${dP.y.toFixed(2)}\n            //           velDueToSpin: ${velDueToSpin.x.toFixed(2)},${velDueToSpin.y.toFixed(2)}\n            //           dirDueToSpin: ${dirDueToSpin.x.toFixed(2)},${dirDueToSpin.y.toFixed(2)}\n            //               totalVel: ${totalVel.x.toFixed(2)},${totalVel.y.toFixed(2)}\n            //    totalSpeedInSpinDir: ${totalSpeedInSpinDir.toFixed(2)}\n            //        totalAngularVel: ${totalAngularVel.toFixed(2)}\n            //  `)\n            //}\n            return {\n                totalVel,\n                totalAngularVel,\n                totalSpeedInSpinDir,\n                dirDueToSpin,\n            };\n        }\n    }\n    getBallMaxHeight(gravity) {\n        const vy = this.vel.y;\n        const py = this.center.y;\n        const energyPermass = py * -gravity.y + (vy * vy) / 2;\n        const maxHeight = energyPermass / -gravity.y;\n        return maxHeight;\n    }\n    handleHittingOtherCircle(other, elasticity, isSimulation) {\n        const result = {\n            didCollide: false,\n            angle: 0,\n            pointOfContact: { x: Infinity, y: Infinity },\n            c1MomentumDelta: { x: Infinity, y: Infinity },\n            c2MomentumDelta: { x: Infinity, y: Infinity },\n            c1EnergyDelta: Infinity,\n            c2EnergyDelta: Infinity,\n        };\n        // Exit early if their rectangles don't overlap\n        const thisRadius = this.radius;\n        const otherRadius = other.radius;\n        if (this.center.x + thisRadius < other.center.x - otherRadius ||\n            this.center.x - thisRadius > other.center.x + otherRadius ||\n            this.center.y + thisRadius < other.center.y - otherRadius ||\n            this.center.y - thisRadius > other.center.y + otherRadius)\n            return result;\n        const ed = elasticity; // elasticity\n        const displacement = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(this.center, other.center);\n        const distance = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.len(displacement);\n        if (distance < this.radius + other.radius) {\n            const a = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(displacement, 1 / distance);\n            const va1 = this.vel.x * a.x + this.vel.y * a.y;\n            const vb1 = -this.vel.x * a.y + this.vel.y * a.x;\n            const va2 = other.vel.x * a.x + other.vel.y * a.y;\n            const vb2 = -other.vel.x * a.y + other.vel.y * a.x;\n            const vaP1 = va1 + ((1 + ed) * (va2 - va1)) / (1 + this.mass / other.mass);\n            const vaP2 = va2 + ((1 + ed) * (va1 - va2)) / (1 + other.mass / this.mass);\n            const thisOldEnergy = 0.5 * this.mass * _utils__WEBPACK_IMPORTED_MODULE_1__.vec.lenSq(this.vel);\n            const otherOldEnergy = 0.5 * other.mass * _utils__WEBPACK_IMPORTED_MODULE_1__.vec.lenSq(other.vel);\n            const thisOldMomentum = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(this.vel, this.mass);\n            const otherOldMomentum = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(other.vel, other.mass);\n            const pointOfContact = { x: this.center.x - a.x * this.radius, y: this.center.y - a.y * this.radius };\n            const thisSpinInfo = this.getAtomVelocityAtWorldPoint(pointOfContact, isSimulation);\n            const otherSpinInfo = other.getAtomVelocityAtWorldPoint(pointOfContact, isSimulation);\n            // we'll let them add spin to each other, but only if they're not really resting\n            // on each other (rel speeds would be very low in that case)\n            const relSpeed = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.len(_utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(this.vel, other.vel));\n            //if (!isSimulation) console.log(relSpeed)\n            let thisSpinBounceLoss = { x: 0, y: 0 };\n            let otherSpinBounceLoss = { x: 0, y: 0 };\n            if (relSpeed > _tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"].physics.minRelSpeedToAllowBallSpins) {\n                if (this.canSpin) {\n                    const thisAngularVelDelta = _tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"].physics.ballOnBallFrictionSpin * thisSpinInfo.totalAngularVel;\n                    this.angularVel -= thisAngularVelDelta;\n                    const bounceScale = thisSpinInfo.totalSpeedInSpinDir * this.spinBumpOffFrictionPoints;\n                    thisSpinBounceLoss = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(thisSpinInfo.dirDueToSpin, bounceScale);\n                }\n                if (other.canSpin) {\n                    const otherAngularVelDelta = _tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"].physics.ballOnBallFrictionSpin * otherSpinInfo.totalAngularVel;\n                    other.angularVel -= otherAngularVelDelta;\n                    const bounceScale = otherSpinInfo.totalSpeedInSpinDir * other.spinBumpOffFrictionPoints;\n                    //if (!isSimulation) console.log('yo', otherSpinInfo.totalSpeedInSpinDir, other.spinBumpOffFrictionPoints, bounceScale)\n                    otherSpinBounceLoss = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(otherSpinInfo.dirDueToSpin, bounceScale);\n                }\n            }\n            //if (!isSimulation) {\n            //  console.log(this.canSpin, other.canSpin)\n            //  console.log(JSON.stringify({relSpeed, thisSpinBounceLoss, otherSpinBounceLoss, thisVel: this.vel, otherVel: other.vel}, null, 2))\n            //}\n            //if (!isSimulation) {\n            //  console.log(thisAngSpeed, otherAngSpeed, this.orientation, other.orientation)\n            //  //if (thisAngSpeed === 0) console.log({thisAngSpeed, otherAngSpeed, thisAngVel: this.angularVel, otherAngVel: other.angularVel})\n            //}\n            // ok, update their velocities\n            this.vel.x = vaP1 * a.x - vb1 * a.y;\n            this.vel.y = vaP1 * a.y + vb1 * a.x;\n            other.vel.x = vaP2 * a.x - vb2 * a.y;\n            other.vel.y = vaP2 * a.y + vb2 * a.x;\n            // any spinBounceLoss\n            this.vel.x -= thisSpinBounceLoss.x;\n            this.vel.y -= thisSpinBounceLoss.y;\n            other.vel.x -= otherSpinBounceLoss.x;\n            other.vel.y -= otherSpinBounceLoss.y;\n            const thisNewEnergy = 0.5 * this.mass * _utils__WEBPACK_IMPORTED_MODULE_1__.vec.lenSq(this.vel);\n            const otherNewEnergy = 0.5 * other.mass * _utils__WEBPACK_IMPORTED_MODULE_1__.vec.lenSq(other.vel);\n            const thisNewMomentum = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(this.vel, this.mass);\n            const otherNewMomentum = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(other.vel, other.mass);\n            // Finally, make sure displacement is at least radii.\n            const appropriateSeparation = 1.0 * (this.radius + other.radius);\n            if (distance < appropriateSeparation && this.mass > other.mass) {\n                const toSub = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(a, appropriateSeparation - distance);\n                other.center = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(other.center, toSub);\n            }\n            else if (distance < appropriateSeparation && this.mass <= other.mass) {\n                const toAdd = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(a, appropriateSeparation - distance);\n                this.center = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.add(this.center, toAdd);\n            }\n            result.pointOfContact = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.add(other.center, _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(a, other.radius));\n            result.angle = Math.atan2(a.y, a.x);\n            result.c1EnergyDelta = thisNewEnergy - thisOldEnergy;\n            result.c2EnergyDelta = otherNewEnergy - otherOldEnergy;\n            result.c1MomentumDelta = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(thisNewMomentum, thisOldMomentum);\n            result.c2MomentumDelta = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(otherNewMomentum, otherOldMomentum);\n            result.didCollide = true;\n            return result;\n        }\n        else {\n            result.didCollide = false;\n            return result;\n        }\n    }\n    handleHittingPoint(point, elasticity, isSimulation) {\n        const displacement = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(point, this.center);\n        const distance = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.len(displacement);\n        if (distance < this.radius) {\n            const displacementNormal = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.normalized(displacement);\n            const velTowardCollision = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(displacementNormal, _utils__WEBPACK_IMPORTED_MODULE_1__.vec.dotProduct(this.vel, displacementNormal));\n            const velPerpendicularToCollision = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(this.vel, velTowardCollision);\n            this.vel = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.add(velPerpendicularToCollision, _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(velTowardCollision, -1 * elasticity));\n            this.center = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(point, _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(displacementNormal, this.radius));\n            this.adjSpinOffFrictionPoint(point, isSimulation);\n            return true;\n        }\n        return false;\n    }\n    handleHittingVerticalSegment(lowerPoint, upperPoint, elasticity, isSimulation) {\n        if (this.center.y >= lowerPoint.y && this.center.y <= upperPoint.y) {\n            const displacementFromCenter = lowerPoint.x - this.center.x;\n            // if ball hitting, coming from the left\n            if (displacementFromCenter > 0 && displacementFromCenter < this.radius && this.vel.x > 0) {\n                this.adjSpinOffFrictionPoint({ x: this.center.x + this.radius, y: this.center.y }, isSimulation);\n                this.vel.x *= -elasticity;\n                this.center.x = lowerPoint.x - this.radius;\n                return true;\n            }\n            // ball hitting, coming from the right\n            else if (displacementFromCenter < 0 && displacementFromCenter > -this.radius && this.vel.x < 0) {\n                this.adjSpinOffFrictionPoint({ x: this.center.x - this.radius, y: this.center.y }, isSimulation);\n                this.vel.x *= -elasticity;\n                this.center.x = lowerPoint.x + this.radius;\n                return true;\n            }\n        }\n        return false;\n    }\n    handleHittingHorizontalSegment(leftPoint, rightPoint, elasticity, isSimulation) {\n        if (this.center.x >= leftPoint.x && this.center.x <= rightPoint.x) {\n            const displacementFromCenter = leftPoint.y - this.center.y;\n            // if ball hitting, coming from the bottom\n            if (displacementFromCenter > 0 && displacementFromCenter < this.radius && this.vel.y > 0) {\n                this.adjSpinOffFrictionPoint({ x: this.center.x, y: this.center.y + this.radius }, isSimulation);\n                this.vel.y *= -elasticity;\n                this.center.y = leftPoint.y - this.radius;\n                return true;\n            }\n            // ball hitting, coming from the top\n            else if (displacementFromCenter < 0 && displacementFromCenter > -this.radius && this.vel.y < 0) {\n                this.adjSpinOffFrictionPoint({ x: this.center.x, y: this.center.y - this.radius }, isSimulation);\n                this.vel.y *= -elasticity;\n                this.center.y = leftPoint.y + this.radius;\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * when the ball hits a net or wall, it loses some spin (or gains). That energy has to be adjusted from\n     * movement energy though.\n     * @param worldPoint\n     * @param isSimulation\n     */\n    adjSpinOffFrictionPoint(worldPoint, isSimulation) {\n        const spinInfo = this.getAtomVelocityAtWorldPoint(worldPoint, isSimulation);\n        const spinLoss = spinInfo.totalAngularVel * this.spinElasticityOffFrictionPoints;\n        const bounceScale = spinInfo.totalSpeedInSpinDir * this.spinBumpOffFrictionPoints;\n        this.vel = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.sub(this.vel, _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(spinInfo.dirDueToSpin, bounceScale));\n        this.angularVel -= spinLoss;\n        //if (!isSimulation) {\n        //  console.log(`Off point, adj=${spinInfo.totalSpeedInSpinDir}. angularVel=${this.angularVel}`)\n        //}\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/circular-object.ts?");

/***/ }),

/***/ "./src/cloud.ts":
/*!**********************!*\
  !*** ./src/cloud.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cloud\": () => (/* binding */ Cloud)\n/* harmony export */ });\nclass Cloud {\n    // Public Methods\n    constructor(constraint, sunnyTexture, darkTexture, vel, pos, width) {\n        this._age = 0;\n        this._constraint = constraint;\n        this._sunnyTexture = sunnyTexture;\n        this._darkTexture = darkTexture;\n        this._vel = vel;\n        this._pos = pos;\n        this._width = width;\n    }\n    get width() {\n        return this._width;\n    }\n    get sunnyTexture() {\n        return this._sunnyTexture;\n    }\n    get darkTexture() {\n        return this._darkTexture;\n    }\n    get age() {\n        return this._age;\n    }\n    get pos() {\n        return this._pos;\n    }\n    step(dt) {\n        const c = this._constraint;\n        this._pos.x += this._vel.x * dt;\n        this._pos.y += this._vel.y * dt;\n        if (this._vel.x < 0 && this._pos.x < c.x1)\n            this._pos.x = c.x2;\n        if (this._vel.x > 0 && this._pos.x > c.x2)\n            this._pos.x = c.x1;\n        if (this._vel.y < 0 && this._pos.y < c.y1)\n            this._pos.y = c.y2;\n        if (this._vel.y > 0 && this._pos.y > c.y2)\n            this._pos.y = c.y1;\n        if (this._pos.y > c.y2) {\n            this._pos.y = c.y2;\n            this._vel.y = -Math.abs(this._vel.y);\n        }\n        if (this._pos.y < c.y1) {\n            this._pos.y = c.y1;\n            this._vel.y = Math.abs(this._vel.y);\n        }\n        this._age += dt;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/cloud.ts?");

/***/ }),

/***/ "./src/color.ts":
/*!**********************!*\
  !*** ./src/color.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Color\": () => (/* binding */ Color),\n/* harmony export */   \"Colors\": () => (/* binding */ Colors)\n/* harmony export */ });\nclass Color {\n    constructor(r, g, b, a) {\n        if (typeof a !== 'number' || isNaN(a))\n            throw new Error(`I demand alpha.`);\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    toHtmlRgb() {\n        if (this.a === 1)\n            return `rgb(${this.r * 255},${this.g * 255},${this.b * 255})`;\n        else\n            return `rgba(${this.r * 255},${this.g * 255},${this.b * 255},${this.a})`;\n    }\n}\nconst Colors = {\n    white: new Color(1, 1, 1, 1),\n    black: new Color(0, 0, 0, 1),\n};\n\n\n\n//# sourceURL=webpack:///./src/color.ts?");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar _a;\nconst c = {\n    gameLoopDelayMs: 5,\n    expressPort: 3377,\n    assetUrl: `http://localhost:3377/public/`,\n    dpr: (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1,\n    link: 'https://chriscoyne.com',\n    version: '0.2.0',\n    versionDateStr: '27-Jan-2023',\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (c);\n\n\n//# sourceURL=webpack:///./src/constants.ts?");

/***/ }),

/***/ "./src/content-load-list.ts":
/*!**********************************!*\
  !*** ./src/content-load-list.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"soundSources\": () => (/* binding */ soundSources),\n/* harmony export */   \"textureSources\": () => (/* binding */ textureSources)\n/* harmony export */ });\nconst textureSources = {\n    ball1: 'images/Volleyball1.png',\n    ball2: 'images/Volleyball2.png',\n    ballShadow: 'images/BallShadow.png',\n    net: 'images/Net.png',\n    redPlayer: 'images/Players/RedPlayer.png',\n    greenPlayer: 'images/Players/GreenPlayer.png',\n    purplePlayer: 'images/Players/PurplePlayer.png',\n    whitePlayer: 'images/Players/WhitePlayer.png',\n    blackPlayer: 'images/Players/BlackPlayer.png',\n    bluePlayer: 'images/Players/BluePlayer.png',\n    pupil: 'images/Players/Pupil.png',\n    pupilGray: 'images/Players/PupilGray.png',\n    scoreCard: 'images/ScoreCard.png',\n    leftFlower: 'images/FlowerLeft.png',\n    rightFlower: 'images/FlowerRight.png',\n    leftFlowerTop: 'images/FlowerTop1.png',\n    rightFlowerTop: 'images/FlowerTop2.png',\n    floorFront: 'images/FloorFront.png',\n    floorBack: 'images/FloorBack.png',\n    playerShadowBehind: 'images/PlayerShadowBehind.png',\n    playerShadowFront: 'images/PlayerShadowFront.png',\n    gamepad: 'images/Gamepad.png',\n    keyboard: 'images/Keyboard.png',\n    moon: 'images/Atmosphere/Moon.png',\n    predictionDot: 'images/PredictionDot.png',\n    kapowSlam: 'images/Kapows/KapowSlam.png',\n    kapowRejected: 'images/Kapows/KapowRejected.png',\n    kapowScore: 'images/Kapows/KapowScore.png',\n    sunnyCloud1: 'images/Atmosphere/SunnyCloud1.png',\n    darkCloud1: 'images/Atmosphere/DarkCloud1.png',\n    sunnyCloud2: 'images/Atmosphere/SunnyCloud2.png',\n    darkCloud2: 'images/Atmosphere/DarkCloud2.png',\n    sunnyCloud3: 'images/Atmosphere/SunnyCloud3.png',\n    darkCloud3: 'images/Atmosphere/DarkCloud3.png',\n    sunnyCloud4: 'images/Atmosphere/SunnyCloud4.png',\n    darkCloud4: 'images/Atmosphere/DarkCloud4.png',\n    sunnyCloud5: 'images/Atmosphere/SunnyCloud5.png',\n    darkCloud5: 'images/Atmosphere/DarkCloud5.png',\n    sunnyBackgroundBlue: 'images/Atmosphere/SunnyBackground.png',\n    sunnyBackgroundPurplish: 'images/Atmosphere/SunnyBackgroundPurplish.png',\n    sunnyBackgroundGreen: 'images/Atmosphere/SunnyBackgroundGreen.png',\n    sunnyBackgroundBlack: 'images/Atmosphere/SunnyBackgroundBlack.png',\n    sunnyBackgroundFire: 'images/Atmosphere/SunnyBackgroundFire.png',\n    darkBackground: 'images/Atmosphere/DarkBackground.png',\n    /* misc menu cards */\n    menuCardReturnToGame: 'images/MenuCards/ReturnToGame.png',\n    menuCardExit: 'images/MenuCards/Exit.png',\n    menuCardShadow: 'images/MenuCards/Shadow.png',\n    menuCardLockOverlay: 'images/MenuCards/LockOverlay.png',\n    /* human opponent cards */\n    menuCardHuman1Ball: 'images/MenuCards/Human1Ball.png',\n    menuCardHuman2Balls: 'images/MenuCards/Human2Balls.png',\n    /* computer opponent cards */\n    menuCardPlayGreen: 'images/MenuCards/PlayGreen.png',\n    menuCardPlayPurple: 'images/MenuCards/PlayPurple.png',\n    menuCardPlayBlack: 'images/MenuCards/PlayBlack.png',\n    menuCardPlayWhite: 'images/MenuCards/PlayWhite.png',\n};\nconst soundSources = {\n    themeSong: 'sounds/ThemeSong.mp3',\n    flowerBounce: 'sounds/FlowerBounce.mp3',\n    slam: 'sounds/Slam.mp3',\n    rejected: 'sounds/Rejected.mp3',\n    pointScored: 'sounds/PointScored.mp3',\n    gamePlayMusic: 'sounds/GamePlay02.mp3',\n    p1Growth: 'sounds/SizeChange2.mp3',\n    p2Growth: 'sounds/SizeChange1.mp3',\n    p1Shrinkage: 'sounds/SizeChange2.mp3',\n    p2Shrinkage: 'sounds/SizeChange1.mp3',\n    thud: 'sounds/Thud.mp3',\n    ceramicBounce: 'sounds/CeramicBounce.mp3',\n    gamePoint: 'sounds/GamePoint.mp3',\n};\n\n\n\n//# sourceURL=webpack:///./src/content-load-list.ts?");

/***/ }),

/***/ "./src/content-loader.ts":
/*!*******************************!*\
  !*** ./src/content-loader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContentLoader\": () => (/* binding */ ContentLoader)\n/* harmony export */ });\n/* harmony import */ var _sound_effect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sound-effect */ \"./src/sound-effect.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass ContentLoader {\n    constructor(loadMonitor) {\n        this.audioContext = new AudioContext();\n        this.loadStats = { total: 0, done: 0 };\n        this.loadMonitor = loadMonitor;\n    }\n    get isLoaded() {\n        return this.loadStats.total === this.loadStats.done;\n    }\n    loadFont(familyName, url, weight) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.loadStats.total++;\n            const ffd = { weight: `${weight}` };\n            const ff = new FontFace(`${familyName}`, `url(${url})`, ffd);\n            document.fonts.add(ff);\n            yield ff.load();\n            this.loadStats.done++;\n            return ff;\n        });\n    }\n    loadImage(url) {\n        this.loadStats.total++;\n        this.loadMonitor(this.getLoadStats());\n        return new Promise((resolve, reject) => {\n            this.loadStats.done++;\n            const img = new Image();\n            img.onload = () => resolve(img);\n            img.onerror = reject;\n            img.src = url;\n            this.loadMonitor(this.getLoadStats());\n        });\n    }\n    loadTexture2d(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.loadStats.total++;\n            this.loadMonitor(this.getLoadStats());\n            const img = yield this.loadImage(url);\n            this.loadStats.done++;\n            const res = {\n                width: img.width,\n                height: img.height,\n                img: img,\n            };\n            if (isNaN(img.width) || img.width === 0) {\n                throw new Error(`Could not load image asset ${url}`);\n            }\n            this.loadMonitor(this.getLoadStats());\n            return res;\n        });\n    }\n    loadSoundEffect(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.loadStats.total++;\n            this.loadMonitor(this.getLoadStats());\n            const response = yield window.fetch(path);\n            const arrBuffer = yield response.arrayBuffer();\n            const audioBuffer = yield this.audioContext.decodeAudioData(arrBuffer);\n            this.loadStats.done++;\n            this.loadMonitor(this.getLoadStats());\n            return new _sound_effect__WEBPACK_IMPORTED_MODULE_0__.SoundEffect(audioBuffer, this.audioContext);\n        });\n    }\n    getLoadStats() {\n        return {\n            done: this.loadStats.done,\n            total: this.loadStats.total,\n        };\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/content-loader.ts?");

/***/ }),

/***/ "./src/display.ts":
/*!************************!*\
  !*** ./src/display.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Display\": () => (/* binding */ Display)\n/* harmony export */ });\n/* harmony import */ var _ai_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ai/ai */ \"./src/ai/ai.ts\");\n/* harmony import */ var _atmosphere__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./atmosphere */ \"./src/atmosphere.ts\");\n/* harmony import */ var _canvas_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas-manager */ \"./src/canvas-manager.ts\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color */ \"./src/color.ts\");\n/* harmony import */ var _content_load_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./content-load-list */ \"./src/content-load-list.ts\");\n/* harmony import */ var _font_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./font-manager */ \"./src/font-manager.ts\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _kapow_manager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./kapow-manager */ \"./src/kapow-manager.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _score_card__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./score-card */ \"./src/score-card.ts\");\n/* harmony import */ var _sprite_batch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sprite-batch */ \"./src/sprite-batch.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Display {\n    constructor(game, content, targetDiv) {\n        // Properties\n        this.inDebugView = false;\n        // Members\n        this.p0ScoreCard = new _score_card__WEBPACK_IMPORTED_MODULE_9__.ScoreCard();\n        this.p1ScoreCard = new _score_card__WEBPACK_IMPORTED_MODULE_9__.ScoreCard();\n        this.textures = new Map();\n        this.lastCloudDraw = 0;\n        this.game = game;\n        this.content = content;\n        this.canvasManager = new _canvas_manager__WEBPACK_IMPORTED_MODULE_2__.CanvasManager(targetDiv);\n        this.spriteBatch = new _sprite_batch__WEBPACK_IMPORTED_MODULE_10__.SpriteBatch(this.canvasManager);\n        this._atmosphere = new _atmosphere__WEBPACK_IMPORTED_MODULE_1__.Atmosphere(this, this.canvasManager);\n        this.fontManager = new _font_manager__WEBPACK_IMPORTED_MODULE_5__.FontManager(this.content);\n    }\n    loadTexture(path, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const t = yield this.content.loadTexture2d(path);\n            this.textures.set(name, t);\n        });\n    }\n    font(fontName) {\n        return this.fontManager.getFont(fontName);\n    }\n    get atmosphere() {\n        return this._atmosphere;\n    }\n    get canvasWidth() {\n        return this.canvasManager.width;\n    }\n    get canvasHeight() {\n        return this.canvasManager.height;\n    }\n    get ctx() {\n        return this.canvasManager.ctx;\n    }\n    getSpriteBatch() {\n        return this.spriteBatch;\n    }\n    initialDraw() {\n        this.canvasManager.initialDraw();\n    }\n    loadContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.spriteBatch = new _sprite_batch__WEBPACK_IMPORTED_MODULE_10__.SpriteBatch(this.canvasManager);\n            const p = [];\n            Object.entries(_content_load_list__WEBPACK_IMPORTED_MODULE_4__.textureSources).forEach(([name, source]) => p.push(this.loadTexture(source, name)));\n            p.push(this.fontManager.loadContent());\n            yield Promise.all(p);\n            for (let i = 1; i <= 5; i++) {\n                const tSunny = this.getTexture(`sunnyCloud${i}`);\n                const tDark = this.getTexture(`darkCloud${i}`);\n                this.atmosphere.addCloudTextures(tSunny, tDark);\n            }\n            this.atmosphere.fillClouds();\n        });\n    }\n    getTexture(name) {\n        const t = this.textures.get(name);\n        if (!t)\n            throw new Error(`no texture was loaded with name ${name}`);\n        return t;\n    }\n    bounceScoreCard(playerSide) {\n        if (playerSide == _types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Left)\n            this.p0ScoreCard.bounce();\n        else\n            this.p1ScoreCard.bounce();\n    }\n    isSkarball(p) {\n        if (p.species === _player__WEBPACK_IMPORTED_MODULE_8__.PlayerSpecies.Ai && p.ai && (0,_ai_ai__WEBPACK_IMPORTED_MODULE_0__.aiToName)(p.ai) === 'White')\n            return true;\n        return false;\n    }\n    drawPlayer(gameTime, playerSide, player, playerTexture, ball) {\n        const cfg = _tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].player;\n        const isSkarball = this.isSkarball(player);\n        const leftEyeOffset = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.scale(cfg.eyes.leftOffset, player.physics.diameter);\n        const rightEyeOffset = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.scale(cfg.eyes.rightOffset, player.physics.diameter);\n        let leftEyePosition = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(player.physics.center, leftEyeOffset);\n        let rightEyePosition = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(player.physics.center, rightEyeOffset);\n        const leftEyeWidth = cfg.eyes.leftScale * player.physics.diameter;\n        const rightEyeWidth = cfg.eyes.rightScale * player.physics.diameter;\n        let leftEyeHeight = leftEyeWidth;\n        let rightEyeHeight = rightEyeWidth;\n        const blinkFactor = playerSide === _types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Left ? 0 : 1;\n        if (gameTime.totalGameTime.totalMilliseconds % (cfg.eyes.blinkEveryMs + blinkFactor * 1000) < cfg.eyes.blinkDurationMs) {\n            leftEyeHeight *= cfg.eyes.blinkScale;\n            rightEyeHeight *= isSkarball ? 1 : cfg.eyes.blinkScale;\n        }\n        let leftEyeBallDirection = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.sub(ball.physics.center, leftEyePosition);\n        let rightEyeBallDirection = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.sub(ball.physics.center, rightEyePosition);\n        const leftEyeRange = 0.05;\n        const rightEyeRange = isSkarball ? leftEyeRange / 2 : leftEyeRange;\n        leftEyeBallDirection = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.normalized(leftEyeBallDirection);\n        rightEyeBallDirection = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.normalized(rightEyeBallDirection);\n        leftEyePosition = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(leftEyePosition, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.scale(leftEyeBallDirection, player.physics.diameter * leftEyeRange));\n        rightEyePosition = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(rightEyePosition, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.scale(rightEyeBallDirection, player.physics.diameter * rightEyeRange));\n        this.spriteBatch.drawTextureCentered(playerTexture, player.physics.center, { w: player.physics.diameter, h: player.physics.diameter }, player.physics.orientation, 1);\n        const pupil = this.getTexture('pupil');\n        const pupilGray = this.getTexture('pupilGray');\n        this.spriteBatch.drawTextureCentered(pupil, leftEyePosition, { w: leftEyeWidth, h: leftEyeHeight }, 0, 1);\n        const rightPupil = isSkarball ? pupilGray : pupil;\n        this.spriteBatch.drawTextureCentered(rightPupil, rightEyePosition, { w: rightEyeWidth, h: rightEyeHeight }, 0, 1);\n    }\n    drawPlayerShadowBehind(player) {\n        const shadowWidth = player.physics.diameter * 1.1;\n        const shadowHeight = player.physics.diameter / 5;\n        const shadowPosition = { x: player.physics.center.x, y: 0 };\n        this.spriteBatch.drawTextureCentered(this.getTexture('playerShadowBehind'), shadowPosition, { w: shadowWidth, h: shadowHeight }, 0, 1);\n    }\n    drawPlayerShadowFront(player) {\n        const shadowWidth = player.physics.diameter * 1.1;\n        const shadowHeight = player.physics.diameter / 10;\n        const shadowPosition = { x: player.physics.center.x, y: -shadowHeight / 2 };\n        this.spriteBatch.drawTextureCentered(this.getTexture('playerShadowFront'), shadowPosition, { w: shadowWidth, h: shadowHeight }, 0, 1);\n    }\n    drawCenteredDancingMessage(gameTime, text, subtitle, color) {\n        const minHeight = 0.08;\n        const maxHeight = 0.25; // added or subtracted to above\n        const avgHeight = (maxHeight + minHeight) / 2;\n        const heightDev = avgHeight - minHeight;\n        const seconds = gameTime.totalGameTime.totalSeconds;\n        const beat = Math.PI * 2.0 * seconds * (_tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].menu.bpm / 60);\n        const height = avgHeight + heightDev * (Math.sin(beat / 2) / 2 + Math.sin(beat / 8) / 2);\n        const rot = -0.1 + Math.sin(beat) / 50.0;\n        const destination = { x: 0, y: 0.4 };\n        const shift = this.canvasManager.pixelWidth(2);\n        const subFont = this.font('regular');\n        const font = this.font('extraBold');\n        // we draw subtitle first so title is on top when they overlap\n        if (subtitle) {\n            const subtitleRelativeSize = 0.8; // 80% as big as title\n            const subtitleSize = (minHeight + (maxHeight - height)) * subtitleRelativeSize;\n            destination.y -= subtitleSize * 2;\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(destination, { x: shift, y: shift }), _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, rot);\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(destination, { x: shift, y: -shift }), _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, rot);\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(destination, { x: -shift, y: shift }), _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, rot);\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(destination, { x: -shift, y: -shift }), _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, rot);\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, destination, color, rot);\n            destination.y += subtitleSize;\n        }\n        this.spriteBatch.drawStringCentered(text, font, height, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(destination, { x: shift, y: shift }), _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, rot);\n        this.spriteBatch.drawStringCentered(text, font, height, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(destination, { x: shift, y: -shift }), _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, rot);\n        this.spriteBatch.drawStringCentered(text, font, height, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(destination, { x: -shift, y: shift }), _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, rot);\n        this.spriteBatch.drawStringCentered(text, font, height, _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(destination, { x: -shift, y: -shift }), _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, rot);\n        this.spriteBatch.drawStringCentered(text, font, height, destination, color, rot);\n    }\n    getPlayerTexture(playerSide) {\n        const player = this.game.player(playerSide);\n        if (player.ai) {\n            const aiName = (0,_ai_ai__WEBPACK_IMPORTED_MODULE_0__.aiToName)(player.ai);\n            if (aiName === 'Black')\n                return this.getTexture('blackPlayer');\n            else if (aiName === 'Green')\n                return this.getTexture('greenPlayer');\n            else if (aiName === 'Purple')\n                return this.getTexture('purplePlayer');\n            else\n                return this.getTexture('whitePlayer');\n        }\n        else if (playerSide == _types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Left)\n            return this.getTexture('redPlayer');\n        else\n            return this.getTexture('bluePlayer');\n    }\n    drawControllerInstructions() {\n        // TODO\n        const c = new _color__WEBPACK_IMPORTED_MODULE_3__.Color(1, 1, 1, 1);\n        this.spriteBatch.drawStringCentered('Instructions soon', this.font('regular'), 0.1, { x: 0, y: 0.1 }, c, 0);\n    }\n    drawCredits(gameTime) {\n        console.log(`Todo, draw credits at ${gameTime.totalGameTime.totalSeconds}`);\n    }\n    drawKapows(k) {\n        for (const kapow of k.kapows) {\n            let texture;\n            switch (kapow.kapowType) {\n                case _kapow_manager__WEBPACK_IMPORTED_MODULE_7__.KapowType.Slam:\n                    texture = this.getTexture('kapowSlam');\n                    break;\n                case _kapow_manager__WEBPACK_IMPORTED_MODULE_7__.KapowType.Rejected:\n                    texture = this.getTexture('kapowRejected');\n                    break;\n                case _kapow_manager__WEBPACK_IMPORTED_MODULE_7__.KapowType.Score:\n                    texture = this.getTexture('kapowScore');\n                    break;\n                default:\n                    texture = this.getTexture('kapowSlam');\n                    break;\n            }\n            const alpha = 1 - kapow.fractionOfWayToDeath();\n            this.spriteBatch.drawTextureCentered(texture, kapow.pos, { w: kapow.size, h: kapow.size }, kapow.orientation, alpha);\n        }\n    }\n    draw(gameTime, gameState, p0Score, p1Score, futurePrediction, kapowManager, currentFps, gamepadConnectSummary) {\n        var _a;\n        this.canvasManager.clearCanvas();\n        const playerLeft = this.game.playerLeft;\n        const playerRight = this.game.playerRight;\n        const playerTextures = new Map();\n        playerTextures.set(_types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Left, this.getPlayerTexture(_types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Left));\n        playerTextures.set(_types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Right, this.getPlayerTexture(_types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Right));\n        const dt = (gameTime.totalGameTime.totalMilliseconds - this.lastCloudDraw) / 1000.0;\n        this.p0ScoreCard.update(dt);\n        this.p1ScoreCard.update(dt);\n        this.atmosphere.step(dt);\n        this.lastCloudDraw = gameTime.totalGameTime.totalMilliseconds;\n        this.atmosphere.draw(this.spriteBatch);\n        const viewableRegion = this.canvasManager.viewableRegion;\n        this.spriteBatch.drawTextureInRect(this.getTexture('floorBack'), {\n            x1: viewableRegion.x1 - 0.1,\n            x2: viewableRegion.x2 + 0.1,\n            y1: _tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].floorBack.yMin,\n            y2: _tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].floorBack.yMax,\n        }, 1);\n        if (gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PreExitMessage &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro1 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro2 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro3 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.MainMenu) {\n            this.drawPlayerShadowBehind(playerLeft);\n            this.drawPlayerShadowBehind(playerRight);\n            this.drawKapows(kapowManager);\n            for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Right]) {\n                const player = this.game.player(playerSide);\n                let closestBall = this.game.balls[0];\n                let closestDistance = Infinity;\n                for (const ball of this.game.balls) {\n                    const distance = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.lenSq(_utils__WEBPACK_IMPORTED_MODULE_13__.vec.sub(ball.physics.center, player.physics.center));\n                    if (distance < closestDistance) {\n                        closestDistance = distance;\n                        closestBall = ball;\n                    }\n                }\n                const texture = (_a = playerTextures.get(playerSide)) !== null && _a !== void 0 ? _a : this.getTexture('redPlayer');\n                this.drawPlayer(gameTime, playerSide, player, texture, closestBall);\n            }\n            for (let i = 0; i < this.game.balls.length; i++) {\n                this.drawBall(this.game.balls[i], i);\n            }\n        }\n        this.spriteBatch.drawTextureInRect(this.getTexture('floorFront'), {\n            x1: viewableRegion.x1 - 0.1,\n            x2: viewableRegion.x2 + 0.1,\n            y1: viewableRegion.y1 - 0.1,\n            y2: _tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].floorFront.yMax,\n        }, 1);\n        if (gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PreExitMessage &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro1 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro2 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro3 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.MainMenu) {\n            this.drawPlayerShadowFront(playerLeft);\n            this.drawPlayerShadowFront(playerRight);\n        }\n        const leftTreeTopWidth = this.game.leftWall.width * 2.5;\n        const leftFlowerTop = this.getTexture('leftFlowerTop');\n        const rightFlowerTop = this.getTexture('rightFlowerTop');\n        const leftTreeTopHeight = (leftTreeTopWidth * leftFlowerTop.height) / leftFlowerTop.width;\n        const rightTreeTopWidth = this.game.rightWall.width * 2.5;\n        const rightTreeTopHeight = (rightTreeTopWidth * rightFlowerTop.height) / rightFlowerTop.width;\n        const net = this.game.net;\n        this.spriteBatch.drawTextureCentered(this.getTexture('net'), net.center, { w: net.width, h: net.height }, 0, 1);\n        this.drawFlowers(leftTreeTopWidth, leftTreeTopHeight, rightTreeTopWidth, rightTreeTopHeight);\n        if (gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.MainMenu &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PreStart &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PreExitMessage &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PreExitCredits &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro1 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro2 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro3) {\n            this.drawScores(p0Score, p1Score, gameTime);\n        }\n        this.drawDebugView(futurePrediction, currentFps);\n        this.drawGamepadConnections(gameState, gamepadConnectSummary);\n        if (gameState == _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PreExitMessage) {\n            this.drawCenteredDancingMessage(gameTime, 'They went back to the ground.', null, _color__WEBPACK_IMPORTED_MODULE_3__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro1) {\n            this.drawCenteredDancingMessage(gameTime, 'They came from the ground.', null, _color__WEBPACK_IMPORTED_MODULE_3__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro2) {\n            this.drawCenteredDancingMessage(gameTime, 'They brought a bouncy ball -', null, _color__WEBPACK_IMPORTED_MODULE_3__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_6__.GameState.Intro3) {\n            this.drawCenteredDancingMessage(gameTime, '- and they bounced it around.', null, _color__WEBPACK_IMPORTED_MODULE_3__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_6__.GameState.AutoPaused) {\n            this.drawCenteredDancingMessage(gameTime, 'Please reconnect your controller.', null, _color__WEBPACK_IMPORTED_MODULE_3__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PreExitCredits) {\n            this.drawCenteredDancingMessage(gameTime, 'tcftg.com', 'spread the word', _color__WEBPACK_IMPORTED_MODULE_3__.Colors.white);\n        }\n    }\n    drawFlowers(leftTreeTopWidth, leftTreeTopHeight, rightTreeTopWidth, rightTreeTopHeight) {\n        const leftWall = this.game.leftWall;\n        const rightWall = this.game.rightWall;\n        this.spriteBatch.drawTextureCentered(this.getTexture('leftFlower'), leftWall.center, { w: leftWall.width, h: leftWall.height }, 0, 1);\n        this.spriteBatch.drawTextureCentered(this.getTexture('leftFlowerTop'), { x: leftWall.center.x + leftWall.width / 3, y: leftWall.center.y + leftWall.height / 2 }, { w: leftTreeTopWidth, h: leftTreeTopHeight }, 0, 1);\n        this.spriteBatch.drawTextureCentered(this.getTexture('rightFlower'), rightWall.center, { w: rightWall.width, h: rightWall.height }, 0, 1);\n        this.spriteBatch.drawTextureCentered(this.getTexture('rightFlowerTop'), {\n            x: rightWall.center.x - rightWall.width / 3,\n            y: rightWall.center.y + rightWall.height / 2,\n        }, { w: rightTreeTopWidth, h: rightTreeTopHeight }, 0, 1);\n    }\n    drawBall(ball, i) {\n        const bp = ball.physics;\n        if (i % 2 == 0)\n            this.spriteBatch.drawTextureCentered(this.getTexture('ball1'), bp.center, { w: bp.diameter, h: bp.diameter }, bp.orientation, 1);\n        else\n            this.spriteBatch.drawTextureCentered(this.getTexture('ball2'), bp.center, { w: bp.diameter, h: bp.diameter }, bp.orientation, 1);\n        this.spriteBatch.drawTextureCentered(this.getTexture('ballShadow'), bp.center, { w: bp.diameter, h: bp.diameter }, 0, 1);\n    }\n    drawGamepadConnections(gameState, gCS) {\n        const ignore = [_game__WEBPACK_IMPORTED_MODULE_6__.GameState.Action, _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PreAction, _game__WEBPACK_IMPORTED_MODULE_6__.GameState.PointScored];\n        if (ignore.includes(gameState)) {\n            return;\n        }\n        // draw FPS in bottom right corner\n        const view = this.canvasManager.viewableRegion;\n        //const tlC = this.canvasManager.topLeftCorner()\n        //const bRC = this.canvasManager.bottomRightCorner()\n        const onePixel = this.canvasManager.onePixel;\n        const height = 100;\n        const width = 100;\n        const kbLeftOpacity = gCS.left ? 0.1 : 1;\n        const gpLeftOpacity = gCS.left ? 1 : 0.1;\n        const kbRightOpacity = gCS.right ? 0.1 : 1;\n        const gpRightOpacity = gCS.right ? 1 : 0.1;\n        const kbLeftRect = {\n            x1: view.x1 + 70 * onePixel,\n            x2: view.x1 + 70 * onePixel + onePixel * width,\n            y1: view.y1 + onePixel * height,\n            y2: view.y1 + onePixel * height * 2,\n        };\n        const gpLeftRect = {\n            x1: kbLeftRect.x2 + onePixel * 10,\n            x2: kbLeftRect.x2 + onePixel * (10 + width),\n            y1: view.y1 + onePixel * height,\n            y2: view.y1 + onePixel * height * 2,\n        };\n        this.spriteBatch.drawTextureInRect(this.getTexture('keyboard'), kbLeftRect, kbLeftOpacity);\n        this.spriteBatch.drawTextureInRect(this.getTexture('gamepad'), gpLeftRect, gpLeftOpacity);\n        // now player 2\n        const kbRightRect = {\n            x1: view.x2 - onePixel * width * 3.8 + onePixel * width,\n            x2: view.x2 - onePixel * width * 3.8 + onePixel * width * 2,\n            y1: view.y1 + onePixel * height,\n            y2: view.y1 + onePixel * height * 2,\n        };\n        const gpRightRect = {\n            x1: kbRightRect.x2 + onePixel * 10,\n            x2: kbRightRect.x2 + onePixel * (10 + width),\n            y1: view.y1 + onePixel * height,\n            y2: view.y1 + onePixel * height * 2,\n        };\n        this.spriteBatch.drawTextureInRect(this.getTexture('keyboard'), kbRightRect, kbRightOpacity);\n        this.spriteBatch.drawTextureInRect(this.getTexture('gamepad'), gpRightRect, gpRightOpacity);\n        //console.log(kbLeftRect)\n    }\n    drawDebugView(futurePrediction, currentFps) {\n        var _a;\n        // draw FPS in bottom right corner\n        const view = this.canvasManager.viewableRegion;\n        const onePixel = this.canvasManager.onePixel;\n        const height = onePixel * 36;\n        const xPos = view.x1 + height * 2;\n        const yPos = view.y1 + height * 2;\n        const color = new _color__WEBPACK_IMPORTED_MODULE_3__.Color(0, 0, 0, 0.25);\n        const font = this.font('regular');\n        this.spriteBatch.drawStringUncentered(`${~~currentFps} fps`, font, height, { x: xPos, y: yPos }, color, 0);\n        const suggAt = 90;\n        if (currentFps && currentFps < suggAt) {\n            const opacity = 0.5 * (1 - currentFps / suggAt);\n            this.spriteBatch.drawStringUncentered(`lmk if a smaller window improves smoothness/fps`, font, height * 0.75, { x: xPos, y: yPos - height * 1.1 }, new _color__WEBPACK_IMPORTED_MODULE_3__.Color(0, 0, 0, opacity), 0);\n        }\n        currentFps;\n        if (this.inDebugView) {\n            const alpha = (s) => 1 - Math.sqrt(s.time / _tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].predictionLookaheadSec);\n            for (let i = 0; i < this.game.balls.length; i++) {\n                const ball = this.game.balls[i];\n                const prediction = futurePrediction[i];\n                for (const state of (_a = prediction.ballStates) !== null && _a !== void 0 ? _a : []) {\n                    this.spriteBatch.drawTextureCentered(this.getTexture('predictionDot'), state.pos, { w: 0.01, h: 0.01 }, 0, alpha(state));\n                }\n                for (const s of [_types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_12__.PlayerSide.Right]) {\n                    const entrance = prediction.ballEnteringJumpRange(s);\n                    if (entrance === null || entrance === void 0 ? void 0 : entrance.isKnown)\n                        this.spriteBatch.drawTextureCentered(this.getTexture('kapowScore'), entrance.pos, { w: ball.physics.diameter, h: ball.physics.diameter }, 0, alpha(entrance));\n                }\n                const groundHit = prediction.ballHittingGround;\n                if (groundHit === null || groundHit === void 0 ? void 0 : groundHit.isKnown)\n                    this.spriteBatch.drawTextureCentered(this.getTexture('kapowScore'), prediction.ballHittingGround.pos, { w: ball.physics.diameter, h: ball.physics.diameter }, 0, alpha(groundHit));\n            }\n        }\n    }\n    drawMenuBanner(bannerTexture, gameTime, center) {\n        const seconds = gameTime.totalGameTime.totalSeconds;\n        const beat = 2.0 * Math.PI * seconds * (_tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].menu.bpm / 60); // 87bmp\n        const destination = center;\n        const sizeMultiplier = 0.05 + Math.sin(beat / 2) / 40 + Math.sin(beat / 8) / 40;\n        const scale = { x: sizeMultiplier, y: sizeMultiplier };\n        const rect = {\n            x1: destination.x,\n            y1: destination.y,\n            x2: destination.x + scale.x,\n            y2: destination.y + scale.y,\n        };\n        this.spriteBatch.drawTextureInRect(bannerTexture, rect, 1);\n    }\n    drawScores(p0Score, p1Score, gameTime) {\n        const seconds = gameTime.totalGameTime.totalSeconds;\n        const rotMax = 0.02;\n        const rotation = rotMax + 2 * rotMax * Math.sin(gameTime.totalGameTime.totalSeconds);\n        const scaleMax = 0.1;\n        const beat = 2.0 * Math.PI * seconds * (_tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].menu.bpm / 60); // 87bmp\n        const extraScale = 1 - scaleMax * Math.sin(beat / 4) - scaleMax * Math.sin(beat / 8);\n        const view = this.canvasManager.viewableRegion;\n        const scoreCardHeight = ((view.y2 - view.y1) / 10) * extraScale;\n        const y = (9 * view.y2 + view.y1) / 10; // most of the way towards tL.y\n        const x1 = (9 * view.x1 + view.x2) / 10; // most of the way to the left side\n        const x2 = (9 * view.x2 + view.x1) / 10; //  most of the way to the right side\n        const box1Center = { x: x1, y };\n        const box2Center = { x: x2, y };\n        const text1 = `${p0Score}`;\n        const p0h = this.p0ScoreCard.sizeMultiplier * scoreCardHeight;\n        this.spriteBatch.drawTextureCentered(this.getTexture('scoreCard'), box1Center, { w: p0h, h: p0h }, rotation, 1);\n        const font = this.font('extraBold');\n        const t0Center = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(box1Center, _tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].display.scorecard.textOffset);\n        const t0Size = 0.9 * p0h * this.p1ScoreCard.sizeMultiplier;\n        this.spriteBatch.drawStringCentered(text1, font, t0Size, t0Center, _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, -rotation);\n        const text2 = `${p1Score}`;\n        const p1h = this.p1ScoreCard.sizeMultiplier * scoreCardHeight;\n        this.spriteBatch.drawTextureCentered(this.getTexture('scoreCard'), box2Center, { w: p1h, h: p1h }, rotation, 1);\n        const t1Center = _utils__WEBPACK_IMPORTED_MODULE_13__.vec.add(box2Center, _tweakables__WEBPACK_IMPORTED_MODULE_11__[\"default\"].display.scorecard.textOffset);\n        const t1Size = 0.9 * p1h * this.p1ScoreCard.sizeMultiplier;\n        this.spriteBatch.drawStringCentered(text2, font, t1Size, t1Center, _color__WEBPACK_IMPORTED_MODULE_3__.Colors.black, -rotation);\n    }\n    adjustZoomLevel(maxBallHeight, dt) {\n        this.canvasManager.adjustZoomLevel(maxBallHeight, dt);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/display.ts?");

/***/ }),

/***/ "./src/font-manager.ts":
/*!*****************************!*\
  !*** ./src/font-manager.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FontManager\": () => (/* binding */ FontManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst fontsToLoad = {\n    extraBold: { family: 'Nunito Sans', weight: 600, url: '/fonts/NunitoSans/NunitoSans-ExtraBold.ttf' },\n    regular: { family: 'Nunito Sans', weight: 400, url: '/fonts/NunitoSans/NunitoSans-Regular.ttf' },\n};\nclass FontManager {\n    constructor(content) {\n        this.fonts = new Map();\n        this.content = content;\n    }\n    getFont(name) {\n        const res = this.fonts.get(name);\n        if (!res)\n            throw new Error(`Could not getFont() ${name}`);\n        return res;\n    }\n    loadOneFont(name, request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.content.loadFont(request.family, request.url, request.weight);\n            this.fonts.set(name, request);\n        });\n    }\n    loadContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(`Starting to load fonts`);\n            const p = [];\n            const start = Date.now();\n            for (const k of Object.keys(fontsToLoad)) {\n                const fontName = k;\n                const request = fontsToLoad[fontName];\n                p.push(this.loadOneFont(fontName, request));\n            }\n            yield Promise.all(p);\n            console.log(`Fonts loaded in ${Date.now() - start}ms.`);\n            // This will throw an error in many browsers but is good for testing in Chrome/Safari:\n            //console.log(`Fonts loaded in ${Date.now() - start}ms. Now available = `)\n            //for (const f of document.fonts.entries()) {\n            //  console.log('font: ', f)\n            //}\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/font-manager.ts?");

/***/ }),

/***/ "./src/future-prediction.ts":
/*!**********************************!*\
  !*** ./src/future-prediction.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FuturePrediction\": () => (/* binding */ FuturePrediction),\n/* harmony export */   \"unknownState\": () => (/* binding */ unknownState)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nconst unknownState = () => ({\n    pos: { x: Infinity, y: Infinity },\n    time: Infinity,\n    isKnown: false,\n});\nclass FuturePrediction {\n    constructor() {\n        this.ballStates = new Array();\n        this.ballHittingGround = unknownState();\n        this.ballCrossingNet = unknownState();\n        this.ballEnteringPlayerJumpRange = new Map([\n            [_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left, unknownState()],\n            [_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Right, unknownState()],\n        ]);\n    }\n    ballEnteringJumpRange(playerSide) {\n        const res = this.ballEnteringPlayerJumpRange.get(playerSide);\n        if (!res)\n            throw new Error(`Could not check jump range for ${playerSide}`);\n        return res;\n    }\n    setBallEnteringJumpRange(playerSide, futureState) {\n        this.ballEnteringPlayerJumpRange.set(playerSide, futureState);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/future-prediction.ts?");

/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => (/* binding */ Game),\n/* harmony export */   \"GameState\": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_13__.GameState)\n/* harmony export */ });\n/* harmony import */ var _ball__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ball */ \"./src/ball.ts\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ \"./src/color.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _content_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./content-loader */ \"./src/content-loader.ts\");\n/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./display */ \"./src/display.ts\");\n/* harmony import */ var _future_prediction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./future-prediction */ \"./src/future-prediction.ts\");\n/* harmony import */ var _history_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./history-manager */ \"./src/history-manager.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _kapow_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./kapow-manager */ \"./src/kapow-manager.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _sound_manager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sound-manager */ \"./src/sound-manager.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/* harmony import */ var _persistence__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./persistence */ \"./src/persistence.ts\");\n/* harmony import */ var _ai_ai__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ai/ai */ \"./src/ai/ai.ts\");\n/* harmony import */ var _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./rectangular-obstacle */ \"./src/rectangular-obstacle.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Game {\n    constructor(targetDiv, contentLoadMonitor) {\n        this.kapow = new _kapow_manager__WEBPACK_IMPORTED_MODULE_8__.KapowManager();\n        this.history = new _history_manager__WEBPACK_IMPORTED_MODULE_6__.HistoryManager();\n        this.isGamePoint = false;\n        this.scoreLeftPlayer = 0;\n        this.scoreRightPlayer = 0;\n        this.whoseServe = _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left;\n        this.gameState = _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreStart;\n        this.currentGameTime = this.emptyGameTime();\n        this.futurePredictionList = [];\n        this.lastFuturePrediction = 0;\n        this.fpsTimer = new Array();\n        this.players = new Map();\n        this.balls = [];\n        this.net = new _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_17__.RectangularObstacle(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].net);\n        this.leftWall = new _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_17__.RectangularObstacle(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].leftWall);\n        this.rightWall = new _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_17__.RectangularObstacle(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].rightWall);\n        this.invisibleFloor = new _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_17__.RectangularObstacle(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].invisibleFloor);\n        this.accumulatedGamePlayTime = 0; // How much the clock has run this game, in seconds, excluding pauses and between points\n        this.accumulatedStateSeconds = 0; // Time accumulated since last gamestate change\n        this.accumulatedPointSeconds = 0; // Accumulated play time this point (persists even if pausing it to go to menu)\n        this.whenStartedDateTime = Date.now();\n        this.content = new _content_loader__WEBPACK_IMPORTED_MODULE_3__.ContentLoader(contentLoadMonitor);\n        this.generatePlayers(null);\n        this.generateBalls(2);\n        this.resetScores();\n        this.init(targetDiv);\n    }\n    init(targetDiv) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.sound = new _sound_manager__WEBPACK_IMPORTED_MODULE_11__.SoundManager(this.content);\n            this.display = new _display__WEBPACK_IMPORTED_MODULE_4__.Display(this, this.content, targetDiv);\n            this.menu = new _menu__WEBPACK_IMPORTED_MODULE_9__.Menu(this.display);\n            this.input = new _input__WEBPACK_IMPORTED_MODULE_7__.Input(this);\n            yield this.loadContent();\n            this.resetScores();\n            this.display.atmosphere.changeSkyForOpponent(this.playerRight, 1);\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreStart);\n            this.futurePredictionList = [];\n            for (let i = 0; i < this.balls.length; i++) {\n                this.futurePredictionList.push(new _future_prediction__WEBPACK_IMPORTED_MODULE_5__.FuturePrediction());\n            }\n        });\n    }\n    player(playerSide) {\n        const p = this.players.get(playerSide);\n        if (!p)\n            throw new Error(`Pfff, player could not load`);\n        return p;\n    }\n    get playerLeft() {\n        return this.player(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left);\n    }\n    get playerRight() {\n        return this.player(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right);\n    }\n    get isTwoPlayerGame() {\n        return this.playerRight.species === _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Human;\n    }\n    generateBalls(numBalls) {\n        this.balls = [];\n        for (let i = 0; i < numBalls; i++) {\n            const b = new _ball__WEBPACK_IMPORTED_MODULE_0__.Ball({ x: 0, y: 0 }, { x: 0, y: 0 }, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].ball.defaultSettings.diameter, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].ball.defaultSettings.mass, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].ball.defaultSettings.maxSpeed, 0, // Orientation\n            0);\n            this.balls.push(b);\n        }\n    }\n    emptyGameTime() {\n        return {\n            totalGameTime: {\n                totalMilliseconds: 0,\n                totalSeconds: 0,\n            },\n            elapsedGameTime: {\n                totalMilliseconds: 0,\n                totalSeconds: 0,\n            },\n        };\n    }\n    generatePlayers(rightPlayerAi) {\n        const pLeftConfig = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.defaultSettings();\n        const pRightConfig = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.defaultSettings();\n        if (rightPlayerAi) {\n            pRightConfig.species = _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Ai;\n            pRightConfig.ai = rightPlayerAi;\n        }\n        this.players.set(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left, new _player__WEBPACK_IMPORTED_MODULE_10__.Player(pLeftConfig));\n        this.players.set(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right, new _player__WEBPACK_IMPORTED_MODULE_10__.Player(pRightConfig));\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            while (!this.content.isLoaded) {\n                yield (0,_utils__WEBPACK_IMPORTED_MODULE_14__.timeout)(100);\n            }\n            this.whenStartedDateTime = Date.now();\n            this.display.initialDraw();\n            yield this.runLoop();\n        });\n    }\n    updateFps() {\n        this.fpsTimer.push(Date.now());\n        if (this.fpsTimer.length > _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fpsSampleCount) {\n            this.fpsTimer.splice(0, 1);\n        }\n    }\n    getCurrentFps() {\n        const len = this.fpsTimer.length;\n        return len <= 1 ? 0 : 1000 / ((this.fpsTimer[len - 1] - this.fpsTimer[0]) / len);\n    }\n    runLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const startTime = Date.now();\n            let lastDraw = Date.now();\n            let lastTime = Date.now();\n            while (this.gameState !== _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Exit) {\n                this.input.updateInputStates();\n                yield (0,_utils__WEBPACK_IMPORTED_MODULE_14__.timeout)(_constants__WEBPACK_IMPORTED_MODULE_2__[\"default\"].gameLoopDelayMs);\n                const currTime = Date.now();\n                const dt = currTime - lastTime;\n                this.currentGameTime = {\n                    totalGameTime: {\n                        totalMilliseconds: currTime - startTime,\n                        totalSeconds: (currTime - startTime) / 1000,\n                    },\n                    elapsedGameTime: {\n                        totalMilliseconds: dt,\n                        totalSeconds: dt / 1000,\n                    },\n                };\n                this.update(this.currentGameTime);\n                if (Date.now() - lastDraw > _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].redrawTargetMs) {\n                    this.updateFps();\n                    this.draw(this.currentGameTime);\n                    lastDraw = Date.now();\n                }\n                lastTime = currTime;\n            }\n        });\n    }\n    setGameState(gs) {\n        if (gs !== _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreStart) {\n            // hello world\n        }\n        if (gs !== this.gameState)\n            this.accumulatedStateSeconds = 0.0;\n        this.gameState = gs;\n        if (gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action || gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreAction)\n            this.setUpForServe();\n        if (gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.MainMenu ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Paused ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreExitMessage ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreExitCredits ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro1 ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro2 ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro3 ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Victory) {\n            this.sound.playIfNotPlaying('themeSong', 1.0, 0.0, 0.0, true);\n        }\n        else if (gs !== _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreStart) {\n            this.sound.stopThemeMusic();\n        }\n        if (gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action && !this.isGamePoint) {\n            this.sound.playIfNotPlaying('gamePlayMusic', 0.5, 0.0, 0.0, true);\n        }\n        else if (gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Paused || gs === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.AutoPaused) {\n            this.sound.stopPlayMusic();\n        }\n    }\n    loadContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const contentStartTime = Date.now();\n            console.log(`Starting to load content`);\n            yield Promise.all([this.sound.loadContent(), this.display.loadContent()]);\n            console.log(`Finished loading content ${Date.now() - contentStartTime}ms`);\n        });\n    }\n    getPlayerName(playerSide) {\n        if (playerSide === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left)\n            return 'Red';\n        if (this.playerRight.species === _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Human)\n            return 'Blue';\n        else if (this.playerRight.ai) {\n            return (0,_ai_ai__WEBPACK_IMPORTED_MODULE_16__.aiToName)(this.playerRight.ai);\n        }\n        else {\n            return 'Unknown';\n        }\n    }\n    draw(gameTime) {\n        const dt = gameTime.elapsedGameTime.totalSeconds;\n        this.kapow.step(dt);\n        this.display.draw(gameTime, this.gameState, this.scoreLeftPlayer, this.scoreRightPlayer, this.futurePredictionList, this.kapow, this.getCurrentFps(), this.input.gamepadConnectSummary());\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Victory) {\n            this.isGamePoint = false;\n            const seconds = this.accumulatedGamePlayTime;\n            const minutesInt = Math.floor(seconds / 60.0);\n            const secondsInt = Math.floor(seconds - minutesInt * 60);\n            const time = minutesInt > 0 ? `${minutesInt} min ${secondsInt} sec` : `${seconds.toFixed(3)} seconds`;\n            const winner = this.scoreLeftPlayer > this.scoreRightPlayer ? _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left : _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right;\n            const summ = winner === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right && this.playerRight.ai ? `Defeat in ${time}.` : `Victory in ${time}.`;\n            const wPlayer = winner === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right ? this.playerRight : this.playerLeft;\n            if (wPlayer.jumpCount === 0) {\n                this.display.drawCenteredDancingMessage(gameTime, 'Without Jumping!!!', summ, _color__WEBPACK_IMPORTED_MODULE_1__.Colors.white);\n            }\n            else if (this.scoreLeftPlayer === 0 || this.scoreRightPlayer === 0) {\n                this.display.drawCenteredDancingMessage(gameTime, 'Shutout!', summ, _color__WEBPACK_IMPORTED_MODULE_1__.Colors.white);\n            }\n            else {\n                this.display.drawCenteredDancingMessage(gameTime, this.getPlayerName(winner) + ' Wins!', summ, _color__WEBPACK_IMPORTED_MODULE_1__.Colors.white);\n            }\n        }\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PointScored) {\n        }\n        else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Paused) {\n            this.menu.draw(true, gameTime);\n        }\n        else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.MainMenu) {\n            this.menu.draw(false, gameTime);\n        }\n        else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreExitCredits)\n            this.display.drawCredits(gameTime);\n    }\n    startNewGame(numBalls, ai) {\n        this.resetScores();\n        this.generatePlayers(ai);\n        this.whoseServe = ai || Math.random() < 0.5 ? _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left : _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right;\n        this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreAction);\n        const aiName = ai ? (0,_ai_ai__WEBPACK_IMPORTED_MODULE_16__.aiToName)(ai) : undefined;\n        _persistence__WEBPACK_IMPORTED_MODULE_15__.persistence.incGamesStarted(numBalls, this.playerRight.species, aiName);\n        this.accumulatedGamePlayTime = 0.0;\n        this.generateBalls(numBalls);\n        this.setUpForServe();\n        this.display.atmosphere.changeSkyForOpponent(this.playerRight, 1);\n    }\n    handlePreExitInputs() {\n        let stepForward = false;\n        for (let i = 1; i <= 4; i++) {\n            if (this.input.wasMenuSelectJustPushed(null).selected) {\n                stepForward = true;\n            }\n        }\n        if (stepForward && this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreExitCredits)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Exit);\n        else if (stepForward)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreExitCredits);\n    }\n    handleIntroInputs() {\n        let stepForward = false;\n        for (let i = 1; i <= 4; i++) {\n            if (this.input.wasMenuSelectJustPushed(null).selected) {\n                if (Date.now() - this.whenStartedDateTime > 250) {\n                    stepForward = true;\n                }\n            }\n        }\n        if (stepForward && this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro1)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro2);\n        else if (stepForward && this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro2)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro3);\n        else if (stepForward)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.MainMenu);\n    }\n    handleAutoPausedInputs() {\n        // Exit this state if controller reconnected\n        if (this.input.doesPlayerHaveGamepad(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left) &&\n            (this.playerRight.species !== _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Human || this.input.doesPlayerHaveGamepad(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right))) {\n            // Remove menu ownership\n            this.menu.setWhoOwnsMenu(null);\n            // Go to paused menu\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Paused);\n            this.menu.select(_menu__WEBPACK_IMPORTED_MODULE_9__.MenuAction.ReturnToGame, _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left);\n        }\n    }\n    handleMenuInputs() {\n        var _a;\n        const owner = this.menu.getWhoOwnsMenu();\n        const menuSelectResult = this.input.wasMenuSelectJustPushed(owner);\n        if (this.input.wasMenuRightJustPushed(owner))\n            this.menu.moveRight(owner);\n        else if (this.input.wasMenuLeftJustPushed(owner))\n            this.menu.moveLeft(owner);\n        if (menuSelectResult.selected && !this.menu.isOnLockedSelection()) {\n            const gamepadSide = menuSelectResult.byPlayerSide;\n            const entry = this.menu.selectionEntry;\n            const action = entry.action;\n            if (action === _menu__WEBPACK_IMPORTED_MODULE_9__.MenuAction.Play) {\n                const numBalls = (_a = entry.numBalls) !== null && _a !== void 0 ? _a : 1;\n                if (!entry.ai) {\n                    this.startNewGame(numBalls, null);\n                }\n                else {\n                    if (gamepadSide === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right) {\n                        this.input.swapGamepadSides();\n                    }\n                    this.startNewGame(numBalls, new entry.ai());\n                }\n            }\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_9__.MenuAction.Exit)\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreExitMessage);\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_9__.MenuAction.ReturnToGame)\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action);\n        }\n        // Pressing B or Start from Pause returns to Game\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Paused) {\n            if (this.input.wasMenuExitJustPushed(owner))\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action);\n        }\n    }\n    handleVictoryInputs() {\n        if (this.accumulatedStateSeconds > 1.0 && this.input.wasPostgameProceedJustPushed()) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.MainMenu);\n        }\n    }\n    handlePostPointInputs() {\n        // no inputs needed for now; characters get launched back to their starting position.\n        // Consider possibility menu could still be launchable though.\n    }\n    handlePreActionInputs() {\n        if (this.accumulatedStateSeconds > 1.0) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action);\n        }\n    }\n    pauseTheGame(playerSide) {\n        this.menu.setWhoOwnsMenu(playerSide);\n        this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Paused);\n        this.menu.select(_menu__WEBPACK_IMPORTED_MODULE_9__.MenuAction.ReturnToGame, playerSide);\n    }\n    // we wait shortly after the ball to launch them\n    launchPlayersWithGoodTiming() {\n        const stateSec = this.accumulatedStateSeconds;\n        const jumpDelay = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.afterPointJumpDelay;\n        if (stateSec < jumpDelay) {\n            this.playerLeft.physics.center.y = -this.playerLeft.physics.diameter - this.balls[0].physics.diameter;\n            this.playerRight.physics.center.y = -this.playerRight.physics.diameter - this.balls[0].physics.diameter;\n        }\n        else if (stateSec >= jumpDelay &&\n            this.playerLeft.physics.center.y < -this.playerLeft.physics.radius &&\n            this.playerLeft.physics.vel.y <= 0) {\n            this.playerLeft.physics.vel.y = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.jumpSpeedAfterPoint;\n            this.playerRight.physics.vel.y = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.jumpSpeedAfterPoint;\n        }\n    }\n    handleActionInputs(dt) {\n        if (this.accumulatedStateSeconds > _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.afterPointJumpDelay) {\n            this.handleActionInputsForPlayer(dt, _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left);\n            this.handleActionInputsForPlayer(dt, _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right);\n        }\n        // AUTO-PAUSING\n        if (this.input.wasPlayerJustDisconnectedFromGamepad(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left)) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.AutoPaused);\n        }\n        else if (this.playerRight.species === _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Human && this.input.wasPlayerJustDisconnectedFromGamepad(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right)) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.AutoPaused);\n        }\n        // REGULAR PAUSING\n        if (this.input.wasKeyboardPauseHit()) {\n            this.pauseTheGame(null);\n        }\n        else {\n            const padCheckPlayerSide = this.input.checkGamepadPauseHit();\n            if (padCheckPlayerSide !== null) {\n                this.pauseTheGame(padCheckPlayerSide);\n            }\n        }\n    }\n    handleActionInputsForPlayer(dt, playerSide) {\n        const player = this.player(playerSide);\n        if (player.species === _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Human) {\n            player.targetXVel = 0;\n            // the following is -1...1 and maps to 0 if near the center, as determined\n            // in tweakables.thumbstickCenterTolerance\n            const thumbstickPos = this.input.getLeftThumbStickX(playerSide);\n            if (this.input.isLeftPressed(playerSide))\n                player.moveLeft();\n            else if (this.input.isRightPressed(playerSide))\n                player.moveRight();\n            else if (thumbstickPos)\n                player.moveRationally(thumbstickPos);\n            if (player.isInJumpPosition && this.input.isJumpPressed(playerSide))\n                player.jump();\n            // triggers only register over some threshold as dtermined in tweakables.triggerTolerance\n            const lTrigger = this.input.getTrigger(playerSide, 'left');\n            const rTrigger = this.input.getTrigger(playerSide, 'right');\n            const triggerDiff = rTrigger - lTrigger;\n            if (triggerDiff) {\n                player.grow(dt, triggerDiff * _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].input.triggerGrowthMult);\n                this.sound.playGrowthNoise(playerSide, triggerDiff);\n            }\n            else if (this.input.isShrinkPressed(playerSide)) {\n                player.grow(dt, -_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].keyboardGrowthRate);\n                this.sound.playGrowthNoise(playerSide, -_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].keyboardGrowthRate);\n            }\n            else if (this.input.isGrowPressed(playerSide)) {\n                player.grow(dt, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].keyboardGrowthRate);\n                this.sound.playGrowthNoise(playerSide, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].keyboardGrowthRate);\n            }\n            else {\n                this.sound.fadeGrowthNoise(playerSide, dt);\n            }\n        }\n    }\n    canPlayerJump(player, opponent) {\n        if (this.accumulatedStateSeconds < _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].ballPlayerLaunchTime)\n            return false;\n        else if (player.physics.vel.y > player.maxVel.y / 2)\n            return false;\n        else if (player.isOnHeight(0.0))\n            return true;\n        else if (player.isOnRectangle(this.net))\n            return true;\n        else if (player.isOnPlayer(opponent))\n            return true;\n        else\n            return false;\n    }\n    aIStep() {\n        var _a;\n        for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right]) {\n            const p = this.player(playerSide);\n            if (p.species === _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Ai) {\n                const aiThinkArg = {\n                    gameTime: this.currentGameTime,\n                    accumulatedPointSeconds: this.accumulatedPointSeconds,\n                    myPlayerSide: playerSide,\n                    balls: this.balls,\n                    ballPredictions: this.futurePredictionList,\n                    gameGravity: _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity,\n                    p0Score: this.scoreLeftPlayer,\n                    p1Score: this.scoreRightPlayer,\n                    me: playerSide === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left ? this.playerLeft : this.playerRight,\n                    opponent: playerSide === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left ? this.playerRight : this.playerLeft,\n                    net: this.net,\n                };\n                (_a = p.ai) === null || _a === void 0 ? void 0 : _a.think(aiThinkArg);\n            }\n        }\n    }\n    get serveFrom() {\n        return _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].courtWidth / 4;\n    }\n    setUpForServe() {\n        this.accumulatedPointSeconds = 0.0;\n        const playerL = this.playerLeft;\n        const playerR = this.playerRight;\n        playerL.physics.center = { x: -this.serveFrom, y: -playerL.physics.diameter - this.balls[0].physics.diameter };\n        playerL.physics.vel = { x: 0, y: 0 };\n        playerL.targetXVel = 0.0;\n        playerR.physics.center = { x: this.serveFrom, y: -playerR.physics.diameter - this.balls[0].physics.diameter };\n        playerR.physics.vel = { x: 0, y: 0 };\n        playerR.targetXVel = 0.0;\n        this.balls[0].physics.center = {\n            x: this.whoseServe === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left ? -this.serveFrom : this.serveFrom,\n            y: -this.balls[0].physics.radius,\n        };\n        this.balls[0].physics.vel = { x: 0, y: this.balls[0].maxSpeed };\n        this.balls[0].physics.angularVel = 0;\n        this.balls[0].physics.orientation = 0;\n        if (this.balls[1]) {\n            this.balls[1].physics.center = {\n                x: this.whoseServe === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left ? this.serveFrom : -this.serveFrom,\n                y: -this.balls[1].physics.radius * 1.1,\n            };\n            this.balls[1].physics.vel = { x: 0, y: this.balls[1].maxSpeed };\n            this.balls[1].physics.angularVel = 0;\n            this.balls[0].physics.orientation = 0;\n        }\n    }\n    resetScores() {\n        this.scoreLeftPlayer = 0;\n        this.scoreRightPlayer = 0;\n    }\n    checkForAndScorePoint() {\n        let pointForPlayer = null;\n        if (this.accumulatedPointSeconds < _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].ballPlayerLaunchTime)\n            return false;\n        for (const b of this.balls) {\n            const didHit = this.invisibleFloor.handleBallCollision(b.physics, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].physics.ballFloorElasticity, false);\n            if (didHit) {\n                pointForPlayer = b.physics.center.x > this.net.center.x ? _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left : _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right;\n                this.kapow.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_8__.KapowType.Score, b.physics.center, Math.random() / 10, 0.4, 0.5);\n                this.sound.play('pointScored', 0.8, 0.0, b.physics.center.x);\n            }\n        }\n        if (pointForPlayer)\n            this.handlePointScored(pointForPlayer);\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PointScored &&\n            this.scoreLeftPlayer !== this.scoreRightPlayer &&\n            (this.scoreLeftPlayer >= _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].winningScore - 1 || this.scoreRightPlayer >= _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].winningScore - 1)) {\n            this.sound.stopPlayMusic();\n            this.isGamePoint = true;\n            this.sound.playIfNotPlaying('gamePoint', 0.6, 0.0, 0.0, false);\n            this.display.atmosphere.changeSkyForOpponent(this.playerRight, 0);\n        }\n        else if (pointForPlayer) {\n            this.display.atmosphere.changeSkyForOpponent(this.playerRight, 1);\n        }\n        return !!pointForPlayer;\n    }\n    handlePointScored(playerSide) {\n        const winScore = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].winningScore;\n        this.display.bounceScoreCard(playerSide);\n        const sec = this.accumulatedGamePlayTime;\n        const jumps = this.playerLeft.jumpCount;\n        this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.PointScored);\n        if (playerSide === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left) {\n            this.scoreLeftPlayer++;\n            if (this.scoreLeftPlayer >= winScore && this.scoreLeftPlayer - this.scoreRightPlayer >= 2) {\n                _persistence__WEBPACK_IMPORTED_MODULE_15__.persistence.incGamesCompleted();\n                if (this.playerRight.ai) {\n                    const aiName = (0,_ai_ai__WEBPACK_IMPORTED_MODULE_16__.aiToName)(this.playerRight.ai);\n                    const wasShutout = this.scoreRightPlayer === 0;\n                    _persistence__WEBPACK_IMPORTED_MODULE_15__.persistence.recordResultAgainstAi(aiName, true, wasShutout, sec, jumps);\n                }\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Victory);\n            }\n            this.whoseServe = _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left;\n        }\n        else {\n            this.scoreRightPlayer++;\n            if (this.scoreRightPlayer >= winScore && this.scoreRightPlayer - this.scoreLeftPlayer >= 2) {\n                _persistence__WEBPACK_IMPORTED_MODULE_15__.persistence.incGamesCompleted();\n                if (this.playerRight.ai) {\n                    const aiName = (0,_ai_ai__WEBPACK_IMPORTED_MODULE_16__.aiToName)(this.playerRight.ai);\n                    _persistence__WEBPACK_IMPORTED_MODULE_15__.persistence.recordResultAgainstAi(aiName, false, false, sec, jumps);\n                }\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Victory);\n            }\n            this.whoseServe = _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right;\n        }\n    }\n    //\n    // Keeps players constrained by floor and walls\n    //\n    constrainPlayers() {\n        const wallBorder = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].courtWidth / 2;\n        for (const p of this.players.values()) {\n            // Constrain Player to Floor. In the first second of the game they float up from it. After that they stick above it.\n            if (this.accumulatedPointSeconds > _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].ballPlayerLaunchTime && p.physics.center.y < 0.0) {\n                p.physics.center.y = 0.0;\n                if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action && p.physics.vel.y < 0)\n                    p.physics.vel.y = 0;\n            }\n            // Left Wall\n            if (p.physics.center.x < -wallBorder + p.physics.diameter / 2) {\n                p.physics.center.x = -wallBorder + p.physics.diameter / 2;\n                if (p.physics.vel.x < 0)\n                    p.physics.vel.x = 0.0;\n            }\n            // Right Wall\n            if (p.physics.center.x > wallBorder - p.physics.diameter / 2) {\n                p.physics.center.x = wallBorder - p.physics.diameter / 2;\n                if (p.physics.vel.x > 0)\n                    p.physics.vel.x = 0.0;\n            }\n        }\n    }\n    manageCollisions(isSimulation) {\n        const ball0 = this.balls[0];\n        const ball1 = this.balls[1];\n        const playerL = this.playerLeft;\n        const playerR = this.playerRight;\n        // Balls with net, walls, even the floor\n        for (const b of this.balls) {\n            if (this.leftWall.handleBallCollision(b.physics, 1.0, isSimulation) && !isSimulation) {\n                this.sound.playIfNotPlaying('flowerBounce', 0.6, 0.0, -0.5, false);\n            }\n            if (this.rightWall.handleBallCollision(b.physics, 1.0, isSimulation) && !isSimulation)\n                this.sound.playIfNotPlaying('flowerBounce', 0.6, 0.0, 0.5, false);\n            if (this.net.handleBallCollision(b.physics, 1.0, isSimulation) && !isSimulation) {\n                this.sound.playIfNotPlaying('thud', 0.3, 0.0, 0.0, false);\n            }\n            if (this.gameState !== _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action || this.accumulatedPointSeconds > _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].timeOnServeFloorDisappears) {\n                if (this.invisibleFloor.handleBallCollision(b.physics, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].physics.ballFloorElasticity, isSimulation)) {\n                    if (!isSimulation) {\n                        //console.log(this.gameState, this.accumulatedStateSeconds)\n                    }\n                }\n            }\n        }\n        // Balls with other balls\n        if (ball0 && ball1) {\n            const collision = ball0.physics.handleHittingOtherCircle(ball1.physics, 1, isSimulation);\n            if (collision.didCollide && !isSimulation) {\n                const hardness = Math.min(1, _utils__WEBPACK_IMPORTED_MODULE_14__.vec.len(collision.c2MomentumDelta) / ball0.physics.mass / 5.0);\n                const pan = collision.pointOfContact.x;\n                const pitch = 1.0;\n                this.sound.playIfNotPlaying('thud', hardness, pitch, pan, false);\n            }\n        }\n        // Players with net\n        this.net.handleBallCollision(playerL.physics, 0.0, isSimulation);\n        this.net.handleBallCollision(playerR.physics, 0.0, isSimulation);\n        // Players with balls\n        for (const b of this.balls) {\n            this.manageBallPlayerCollision(isSimulation, b, playerL, _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left);\n            this.manageBallPlayerCollision(isSimulation, b, playerR, _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right);\n        }\n        // Player-player collisions\n        playerL.physics.handleHittingOtherCircle(playerR.physics, 0.0, isSimulation);\n    }\n    manageBallPlayerCollision(isSimulation, ball, player, playerSide) {\n        const collision = player.physics.handleHittingOtherCircle(ball.physics, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].physics.ballPlayerElasticity, isSimulation);\n        const isLeft = playerSide === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left;\n        if (!collision.didCollide || isSimulation)\n            return;\n        const hardness = Math.min(1, _utils__WEBPACK_IMPORTED_MODULE_14__.vec.len(collision.c2MomentumDelta) / ball.physics.mass / 5.0);\n        const pan = collision.pointOfContact.x;\n        const pitch = 1.0 -\n            (2.0 * (player.physics.diameter - _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.minDiameter)) / (_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.maxDiameter - _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.minDiameter);\n        this.sound.playIfNotPlaying('thud', hardness, pitch, pan, false);\n        // Slam\n        let amINearnet = false;\n        if (player.physics.center.x > this.net.center.x - (3 * this.net.width) / 2 &&\n            player.physics.center.x < this.net.center.x + (3 * this.net.width) / 2)\n            amINearnet = true;\n        let amIHittingItDown = false;\n        if ((isLeft && ball.physics.vel.x > 0 && ball.physics.vel.y < 0) || (!isLeft && ball.physics.vel.x < 0 && ball.physics.vel.y < 0))\n            amIHittingItDown = true;\n        let amIHighEnough = false;\n        if (player.physics.center.y > player.getMaxJumpHeight(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity.y) / 2)\n            amIHighEnough = true;\n        if (amINearnet &&\n            amIHittingItDown &&\n            amIHighEnough &&\n            !this.history.hasHappenedRecently(`Kapow-Slam-Player-${isLeft ? 0 : 1}`, this.currentGameTime, 0.75)) {\n            this.sound.play('slam', 0.3, 0.0, pan);\n            const dest = _utils__WEBPACK_IMPORTED_MODULE_14__.vec.add(collision.pointOfContact, { x: 0, y: 2 * ball.physics.diameter });\n            this.kapow.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_8__.KapowType.Slam, dest, 0.0, 0.3, 1.5);\n            this.history.recordEvent(`Kapow-Slam-Player-${isLeft ? 0 : 1}`, this.currentGameTime);\n        }\n        // Rejection\n        else if (hardness > 0.1 &&\n            ball.physics.vel.y > 1.0 &&\n            this.history.hasHappenedRecently(`Kapow-Slam-Player-${isLeft ? 1 : 0}`, this.currentGameTime, 0.5) &&\n            !this.history.hasHappenedRecently(`Kapow-Rejected-Player-${isLeft ? 0 : 1}`, this.currentGameTime, 0.25)) {\n            this.sound.playIfNotPlaying('rejected', 0.4, 0.1, 0.0, false);\n            this.kapow.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_8__.KapowType.Rejected, collision.pointOfContact, 0.0, 0.3, 1.5);\n            this.history.recordEvent(`Kapow-Rejected-Player-${isLeft ? 0 : 1}`, this.currentGameTime);\n        }\n    }\n    /**\n     * after a point, we let things move for another moment or two, so it all doesn't just freeze.\n     * Then we freeze for a second and launch everything back into its hole. Once everything is back\n     * underground, we switch the state to PreAction, where the serve is launched.\n     */\n    postPointStep() {\n        const dt = this.currentGameTime.elapsedGameTime.totalMilliseconds / 1000;\n        // if everything is back underground, we can proceed to the next step\n        if (this.playerLeft.physics.center.y < -this.playerLeft.physics.radius &&\n            this.playerRight.physics.center.y < -this.playerRight.physics.radius &&\n            this.balls[0].physics.center.y < -this.balls[0].physics.diameter &&\n            (!this.balls[1] || this.balls[1].physics.center.y < -this.balls[1].physics.diameter)) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreAction);\n        }\n        // just let things move for a bit\n        else if (this.accumulatedStateSeconds < _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].afterPointKeepMovingSec) {\n            let physicsDtCountdown = dt;\n            while (physicsDtCountdown > 0) {\n                const delta = Math.min(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].physicsDtSec, physicsDtCountdown);\n                this.postPointPhysicsStep(delta);\n                physicsDtCountdown -= delta;\n            }\n        }\n        // launch things back towards the start\n        else if (this.accumulatedStateSeconds < _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].afterPointKeepMovingSec + _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].afterPointFreezeSec) {\n            for (const ball of this.balls) {\n                ball.physics.vel = { x: 0, y: ball.maxSpeed };\n            }\n            for (const p of this.players.values()) {\n                p.physics.vel.x = 0.0;\n                p.physics.vel.y = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].player.jumpSpeedAfterPoint;\n            }\n        }\n        // Only move it after that\n        else {\n            const isTwoBallGame = !!this.balls[1];\n            // we launch the balls into the air, and we need to know how long until they are underground\n            const timeTillBallUnderground = (b) => {\n                const v0 = b.physics.vel.y;\n                const c = b.physics.center.y + b.physics.diameter;\n                const a = _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity.y;\n                return (-v0 - Math.sqrt(v0 * v0 - 2 * a * c)) / a;\n            };\n            const timeTillDone = Math.max(timeTillBallUnderground(this.balls[0]), isTwoBallGame ? timeTillBallUnderground(this.balls[1]) : 0.01);\n            for (let i = 0; i < 2; i++) {\n                const ball = this.balls[i];\n                if (ball) {\n                    ball.stepVelocity(dt, _utils__WEBPACK_IMPORTED_MODULE_14__.vec.scale(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity, 1.5), false);\n                    let xDestination = this.whoseServe === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left ? -this.serveFrom : this.serveFrom;\n                    if (isTwoBallGame)\n                        xDestination = this.serveFrom - 2 * this.serveFrom * i;\n                    const xDistance = xDestination - ball.physics.center.x;\n                    ball.physics.vel.x = (3 * xDistance) / timeTillDone;\n                    ball.stepPositionAndOrientation(dt);\n                }\n            }\n            for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right]) {\n                const player = this.player(playerSide);\n                const xDestination = playerSide === _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left ? -this.serveFrom : this.serveFrom;\n                const xDistance = xDestination - player.physics.center.x;\n                player.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity);\n                if (player.physics.center.y < -player.physics.radius) {\n                    player.physics.center.y = -player.physics.diameter - this.balls[0].physics.radius;\n                }\n                else {\n                    player.physics.vel.x = (3 * xDistance) / timeTillDone;\n                    player.stepPosition(dt);\n                }\n            }\n        }\n    }\n    postPointPhysicsStep(dt) {\n        for (const p of this.players.values()) {\n            p.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity);\n            p.stepPosition(dt);\n        }\n        for (const b of this.balls) {\n            b.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity, true);\n            b.stepPositionAndOrientation(dt);\n        }\n        this.manageCollisions(true);\n        this.constrainPlayers();\n    }\n    gameStep(dt) {\n        this.accumulatedGamePlayTime += dt;\n        for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right]) {\n            const player = this.player(playerSide);\n            const opponent = player === this.playerLeft ? this.playerRight : this.playerLeft;\n            player.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity);\n            player.stepPosition(dt);\n            player.setIsInJumpPosition(this.canPlayerJump(player, opponent));\n        }\n        for (const ball of this.balls) {\n            ball.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity, true);\n            ball.stepPositionAndOrientation(dt);\n        }\n        if (this.checkForAndScorePoint()) {\n            this.constrainPlayers();\n            return true;\n        }\n        else {\n            this.launchPlayersWithGoodTiming();\n            this.manageCollisions(false);\n            this.handleActionInputs(dt);\n            this.constrainPlayers();\n            return false;\n        }\n    }\n    simulateStep(dt) {\n        for (const p of this.players.values()) {\n            p.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity);\n            p.stepPosition(dt);\n        }\n        for (const ball of this.balls) {\n            ball.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity, true);\n            ball.stepPositionAndOrientation(dt);\n        }\n        this.manageCollisions(true);\n        this.constrainPlayers();\n    }\n    updateFuturePrediction() {\n        //return;\n        // Copy current player/ball info to temp so we can step w/o wrecking things\n        const sbTemp = [];\n        const p0Real = this.player(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left);\n        const p1Real = this.player(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right);\n        const p0Copy = p0Real.deepCopy();\n        const p1Copy = p1Real.deepCopy();\n        for (let i = 0; i < this.balls.length; i++) {\n            sbTemp[i] = this.balls[i].deepCopy();\n            const prediction = this.futurePredictionList[i];\n            prediction.ballStates = [];\n            // Clear old important markers\n            prediction.ballHittingGround.isKnown = false;\n            prediction.ballCrossingNet.isKnown = false;\n            prediction.ballEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left).isKnown = false;\n            prediction.ballEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right).isKnown = false;\n        }\n        let time = 0;\n        const timeElapsed = this.currentGameTime.totalGameTime.totalSeconds;\n        const p0JumpHeight = p0Copy.getMaxJumpHeight(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity.y);\n        const p1JumpHeight = p1Copy.getMaxJumpHeight(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity.y);\n        while (time < _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].predictionLookaheadSec) {\n            this.simulateStep(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].predictionPhysicsDtSec);\n            time += _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].predictionPhysicsDtSec;\n            const currStep = (time + timeElapsed) / _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].predictionStorageDtSec;\n            const lastStep = (time - _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].predictionPhysicsDtSec + timeElapsed) / _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].predictionStorageDtSec;\n            for (let i = 0; i < this.balls.length; i++) {\n                const state = (0,_future_prediction__WEBPACK_IMPORTED_MODULE_5__.unknownState)();\n                const ballPhysics = this.balls[i].physics;\n                const prediction = this.futurePredictionList[i];\n                state.pos = ballPhysics.center;\n                state.time = time;\n                if (Math.round(currStep) !== Math.round(lastStep)) {\n                    prediction.ballStates.push(state);\n                }\n                if (!prediction.ballHittingGround.isKnown && ballPhysics.center.y - ballPhysics.diameter / 2 <= 0.0) {\n                    prediction.ballHittingGround = state;\n                    prediction.ballHittingGround.isKnown = true;\n                }\n                else if (!prediction.ballCrossingNet.isKnown && Math.abs(ballPhysics.center.x - this.net.center.x) < ballPhysics.diameter / 4.0) {\n                    prediction.ballCrossingNet = state;\n                    prediction.ballCrossingNet.isKnown = true;\n                }\n                if (!prediction.ballEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left).isKnown &&\n                    ballPhysics.center.x < this.net.center.x - this.net.width / 2 &&\n                    ballPhysics.center.y <= p0JumpHeight) {\n                    state.isKnown = true;\n                    prediction.setBallEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left, state);\n                }\n                if (!prediction.ballEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right).isKnown &&\n                    ballPhysics.center.x > this.net.center.x + this.net.width / 2 &&\n                    ballPhysics.center.y <= p1JumpHeight) {\n                    state.isKnown = true;\n                    prediction.setBallEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right, state);\n                }\n            }\n        }\n        for (let i = 0; i < this.balls.length; i++) {\n            this.balls[i] = sbTemp[i];\n        }\n        this.players.set(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Left, p0Copy);\n        this.players.set(_types__WEBPACK_IMPORTED_MODULE_13__.PlayerSide.Right, p1Copy);\n    }\n    runActionState() {\n        const dt = this.currentGameTime.elapsedGameTime.totalMilliseconds / 1000;\n        let physicsDtCountdown = dt;\n        let pointScored = false;\n        if (this.currentGameTime.totalGameTime.totalMilliseconds > this.lastFuturePrediction + _tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].predictFutureEveryMs) {\n            this.updateFuturePrediction();\n            this.lastFuturePrediction = this.currentGameTime.totalGameTime.totalMilliseconds;\n        }\n        while (physicsDtCountdown > 0 && !pointScored) {\n            const delta = Math.min(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].physicsDtSec, physicsDtCountdown);\n            pointScored = this.gameStep(delta);\n            physicsDtCountdown -= delta;\n        }\n        this.aIStep();\n    }\n    runMainMenuState() {\n        this.handleMenuInputs();\n    }\n    runPreExitState() {\n        this.handlePreExitInputs();\n    }\n    runIntroState() {\n        this.handleIntroInputs();\n    }\n    runPausedState() {\n        this.handleMenuInputs();\n    }\n    runAutoPausedState() {\n        this.handleAutoPausedInputs();\n    }\n    runPostPointState() {\n        this.postPointStep();\n        this.handlePostPointInputs();\n    }\n    runPreActionState() {\n        this.handlePreActionInputs();\n    }\n    runVictoryState() {\n        this.handleVictoryInputs();\n    }\n    handleUniversalInputs() {\n        if (this.input.wasDebugKeyJustPushed()) {\n            this.display.inDebugView = !this.display.inDebugView;\n        }\n    }\n    getMaxHeightOfAllBalls() {\n        let highest = -Infinity;\n        for (const ball of this.balls) {\n            highest = Math.max(highest, ball.physics.getBallMaxHeight(_tweakables__WEBPACK_IMPORTED_MODULE_12__[\"default\"].gameGravity));\n        }\n        return highest;\n    }\n    update(gameTime) {\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreStart) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro1);\n        }\n        this.handleUniversalInputs();\n        const dt = gameTime.elapsedGameTime.totalMilliseconds / 1000;\n        this.accumulatedStateSeconds += dt;\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action)\n            this.accumulatedPointSeconds += dt;\n        switch (this.gameState) {\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Action:\n                this.display.adjustZoomLevel(this.getMaxHeightOfAllBalls(), dt);\n                this.runActionState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Paused:\n                this.display.adjustZoomLevel(1000, dt);\n                this.runPausedState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.AutoPaused:\n                this.display.adjustZoomLevel(1000, dt);\n                this.runAutoPausedState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.MainMenu:\n                this.runMainMenuState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro1:\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro2:\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Intro3:\n                this.runIntroState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PointScored:\n                this.runPostPointState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreAction:\n                this.runPreActionState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Victory:\n                this.display.adjustZoomLevel(1000, dt);\n                this.runVictoryState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreExitMessage:\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.PreExitCredits:\n                this.runPreExitState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_13__.GameState.Exit:\n                return false;\n        }\n        return true;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/game.ts?");

/***/ }),

/***/ "./src/gamepad-monitor.ts":
/*!********************************!*\
  !*** ./src/gamepad-monitor.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GamepadMonitor\": () => (/* binding */ GamepadMonitor)\n/* harmony export */ });\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass GamepadMonitor {\n    constructor() {\n        this.currAssigned = new Map();\n        this.prevAssigned = new Map();\n        this.unassigned = new Array();\n        this.currState = new Map();\n        this.prevState = new Map();\n        window.addEventListener('gamepadconnected', (e) => this.connect(e.gamepad));\n        window.addEventListener('gamepaddisconnected', (e) => this.disconnect(e.gamepad));\n        this.pollingLoop();\n    }\n    update() {\n        this.prevState = new Map();\n        for (const [gamepadId, gamepadState] of this.currState.entries()) {\n            this.prevState.set(gamepadId, gamepadState);\n        }\n        this.currState = new Map();\n        const gamepads = navigator.getGamepads();\n        for (const gamepad of gamepads) {\n            if (gamepad) {\n                const state = this.getStateFromGamepad(gamepad);\n                this.currState.set(gamepad.id, state);\n            }\n        }\n        this.prevAssigned = new Map(this.currAssigned);\n    }\n    swapSides() {\n        console.log(`Swapping controller sides`);\n        const prevLeft = this.currAssigned.get(_types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Left);\n        const prevRight = this.currAssigned.get(_types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Right);\n        this.currAssigned = new Map();\n        if (prevLeft)\n            this.currAssigned.set(_types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Right, prevLeft);\n        if (prevRight)\n            this.currAssigned.set(_types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Left, prevRight);\n    }\n    wasPlayerJustDisconnected(playerSide) {\n        return !this.currAssigned.has(playerSide) && this.prevAssigned.has(playerSide);\n    }\n    wasPlayerJustConnected(playerSide) {\n        return this.currAssigned.has(playerSide) && !this.prevAssigned.has(playerSide);\n    }\n    doesPlayerHaveGamepad(playerSide) {\n        return this.currAssigned.has(playerSide);\n    }\n    wasThumbstickPushedXBy(playerSide, stickName, x) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (!gamepad)\n            return false;\n        const currState = this.currState.get(gamepad.id);\n        const prevState = this.prevState.get(gamepad.id);\n        let currPushed;\n        let prevPushed;\n        if (x < 0) {\n            currPushed = currState ? currState.thumbSticks[stickName].x < x : false;\n            prevPushed = prevState ? prevState.thumbSticks[stickName].x < x : false;\n        }\n        else {\n            currPushed = currState ? currState.thumbSticks[stickName].x > x : false;\n            prevPushed = prevState ? prevState.thumbSticks[stickName].x > x : false;\n        }\n        if (currPushed && !prevPushed)\n            return true;\n        return false;\n    }\n    wasThumbstickPushedLeftBy(playerSide, thumbstickName) {\n        return this.wasThumbstickPushedXBy(playerSide, thumbstickName, -_tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"].input.thumbstickPush);\n    }\n    wasThumbstickPushedRightBy(playerSide, thumbstickName) {\n        return this.wasThumbstickPushedXBy(playerSide, thumbstickName, _tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"].input.thumbstickPush);\n    }\n    wasThumbstickPushedLeft(thumbstickName) {\n        for (const playerSide of this.currAssigned.keys()) {\n            const found = this.wasThumbstickPushedLeftBy(playerSide, thumbstickName);\n            if (found)\n                return true;\n        }\n        return false;\n    }\n    wasThumbstickPushedRight(thumbstickName) {\n        for (const playerSide of this.currAssigned.keys()) {\n            const found = this.wasThumbstickPushedRightBy(playerSide, thumbstickName);\n            if (found)\n                return true;\n        }\n        return false;\n    }\n    anyButtonsPushedByAnyone(buttonNames) {\n        for (const playerSide of this.currAssigned.keys()) {\n            const found = this.anyButtonsPushedBy(playerSide, buttonNames);\n            if (found)\n                return true;\n        }\n        return false;\n    }\n    anyButtonDown(playerSide, buttonNames) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (gamepad) {\n            for (const buttonName of buttonNames) {\n                const currState = this.currState.get(gamepad.id);\n                if (currState) {\n                    if (currState.buttons[buttonName]) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    anyButtonsPushedBy(playerSide, buttonNames) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (gamepad) {\n            for (const buttonName of buttonNames) {\n                const currState = this.currState.get(gamepad.id);\n                const prevState = this.prevState.get(gamepad.id);\n                const currPushed = currState && currState.buttons[buttonName];\n                const prevPushed = prevState && prevState.buttons[buttonName];\n                if (currPushed && !prevPushed) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    getTrigger(playerSide, triggerName) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (gamepad) {\n            const state = this.currState.get(gamepad.id);\n            if (state)\n                return state.triggers[triggerName];\n            else\n                0;\n        }\n        return 0;\n    }\n    getThumbStick(playerSide, thumbstickName) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (gamepad) {\n            const state = this.currState.get(gamepad.id);\n            if (state)\n                return state.thumbSticks[thumbstickName];\n            else\n                return { x: 0, y: 0 };\n        }\n        return { x: 0, y: 0 };\n    }\n    getStateFromPlayer(playerSide) {\n        const gp = this.currAssigned.get(playerSide);\n        const prev = this.prevAssigned.get(playerSide);\n        if (!gp || !prev)\n            return null;\n        return this.getStateFromGamepad(gp);\n    }\n    getStateFromGamepad(gamepad) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;\n        const { buttons, axes } = gamepad;\n        return {\n            isConnected: true,\n            triggers: {\n                left: buttons[6].value,\n                right: buttons[7].value,\n            },\n            thumbSticks: {\n                left: { x: axes[0], y: axes[1] },\n                right: { x: axes[2], y: axes[3] },\n            },\n            buttons: {\n                dPadUp: (_b = (_a = buttons[12]) === null || _a === void 0 ? void 0 : _a.pressed) !== null && _b !== void 0 ? _b : false,\n                dPadDown: (_d = (_c = buttons[13]) === null || _c === void 0 ? void 0 : _c.pressed) !== null && _d !== void 0 ? _d : false,\n                dPadLeft: (_f = (_e = buttons[14]) === null || _e === void 0 ? void 0 : _e.pressed) !== null && _f !== void 0 ? _f : false,\n                dPadRight: (_h = (_g = buttons[15]) === null || _g === void 0 ? void 0 : _g.pressed) !== null && _h !== void 0 ? _h : false,\n                psX: (_k = (_j = gamepad.buttons[0]) === null || _j === void 0 ? void 0 : _j.pressed) !== null && _k !== void 0 ? _k : false,\n                psO: (_m = (_l = gamepad.buttons[1]) === null || _l === void 0 ? void 0 : _l.pressed) !== null && _m !== void 0 ? _m : false,\n                start: (_p = (_o = gamepad.buttons[9]) === null || _o === void 0 ? void 0 : _o.pressed) !== null && _p !== void 0 ? _p : false,\n                leftStick: (_r = (_q = gamepad.buttons[10]) === null || _q === void 0 ? void 0 : _q.pressed) !== null && _r !== void 0 ? _r : false,\n                rightStick: (_t = (_s = gamepad.buttons[11]) === null || _s === void 0 ? void 0 : _s.pressed) !== null && _t !== void 0 ? _t : false,\n                rightShoulder: (_v = (_u = gamepad.buttons[5]) === null || _u === void 0 ? void 0 : _u.pressed) !== null && _v !== void 0 ? _v : false,\n            },\n        };\n    }\n    // some older browsers may miss a connect/disconnect\n    // annoying that this has to exist\n    pollingLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            while (true) {\n                yield (0,_utils__WEBPACK_IMPORTED_MODULE_2__.timeout)(500);\n                const gamepads = navigator.getGamepads().reduce((arr, gp) => {\n                    gp && arr.push(gp);\n                    return arr;\n                }, new Array());\n                // notice anything new connected\n                for (const gamepad of gamepads) {\n                    if (!this.isKnownYet(gamepad)) {\n                        this.connect(gamepad);\n                    }\n                }\n                // notice anything previously connected that disappeared\n                for (const prev of this.getAssignedAndUnassigned()) {\n                    if (gamepads.filter((gp) => gp.id === prev.id).length === 0) {\n                        this.disconnect(prev);\n                    }\n                }\n            }\n        });\n    }\n    getAssignedAndUnassigned() {\n        return Array.from(this.currAssigned.values()).concat(this.unassigned);\n    }\n    isKnownYet(gamepad) {\n        for (const candidate of this.getAssignedAndUnassigned()) {\n            if (gamepad.id === candidate.id)\n                return true;\n        }\n        return false;\n    }\n    connect(gamepad) {\n        if (!this.isKnownYet(gamepad)) {\n            this.unassigned.push(gamepad);\n            console.log('connected', gamepad);\n            this.updateAssignments();\n        }\n    }\n    updateAssignments() {\n        for (const pSide of [_types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Right]) {\n            if (!this.currAssigned.get(pSide) && this.unassigned.length) {\n                const gamePad = this.unassigned.splice(0, 1)[0];\n                this.currAssigned.set(pSide, gamePad);\n            }\n        }\n    }\n    disconnect(gamepad) {\n        // remove from assigned\n        for (const pSide of [_types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Right]) {\n            const gamePad = this.currAssigned.get(pSide);\n            if (gamePad && gamePad.id === gamepad.id) {\n                console.log('disconnected from assigned', gamepad);\n                this.currAssigned.delete(pSide);\n            }\n        }\n        // remove from unassigned\n        this.unassigned = this.unassigned.filter((u) => u.id !== gamepad.id);\n        this.updateAssignments();\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/gamepad-monitor.ts?");

/***/ }),

/***/ "./src/history-manager.ts":
/*!********************************!*\
  !*** ./src/history-manager.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HistoryManager\": () => (/* binding */ HistoryManager)\n/* harmony export */ });\nclass HistoryManager {\n    constructor() {\n        this.lastTimeRecorder = new Map();\n    }\n    recordEvent(eventName, gameTime) {\n        this.lastTimeRecorder.set(eventName, gameTime.totalGameTime.totalSeconds);\n    }\n    hasHappenedRecently(eventName, gameTime, seconds) {\n        const lastTime = this.lastTimeRecorder.get(eventName);\n        if (!lastTime)\n            return false;\n        if (gameTime.totalGameTime.totalSeconds - lastTime > seconds)\n            return false;\n        return true;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/history-manager.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _page_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./page-ui */ \"./src/page-ui.ts\");\n\nconst el = document.getElementById('tcftg-wrapper');\nnew _page_ui__WEBPACK_IMPORTED_MODULE_0__.PageUi(el);\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/input.ts":
/*!**********************!*\
  !*** ./src/input.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Input\": () => (/* binding */ Input)\n/* harmony export */ });\n/* harmony import */ var _gamepad_monitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gamepad-monitor */ \"./src/gamepad-monitor.ts\");\n/* harmony import */ var _keyboard_monitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard-monitor */ \"./src/keyboard-monitor.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\n\n\n\n\nclass Input {\n    constructor(game) {\n        this.pads = new _gamepad_monitor__WEBPACK_IMPORTED_MODULE_0__.GamepadMonitor();\n        this.keyboard = new _keyboard_monitor__WEBPACK_IMPORTED_MODULE_1__.KeyboardMonitor();\n        this.game = game;\n    }\n    updateInputStates() {\n        this.keyboard.update();\n        this.pads.update();\n    }\n    isKeyboardConnected() {\n        return true; // for now\n    }\n    getKeyboardSet(pI) {\n        const isTwoPlayerGame = this.game.playerRight.species === _player__WEBPACK_IMPORTED_MODULE_2__.PlayerSpecies.Human;\n        const kSet = isTwoPlayerGame ? _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].twoPlayerControls : _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].onePlayerControls;\n        if (pI === _types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left)\n            return kSet.p0;\n        else\n            return kSet.p1;\n    }\n    swapGamepadSides() {\n        this.pads.swapSides();\n    }\n    wasKeyboardPauseHit() {\n        return this.keyboard.anyKeysJustPushed(['Enter', 'Space']);\n    }\n    checkGamepadPauseHit() {\n        for (const pI of [_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right]) {\n            if (this.pads.anyButtonsPushedBy(pI, ['start']))\n                return pI;\n        }\n        return null;\n    }\n    wasMenuSelectJustPushed(owner) {\n        const res = {\n            selected: false,\n            byPlayerSide: null,\n            byKeyboard: false,\n        };\n        if (this.keyboard.anyKeysJustPushed(['Enter', 'Space'])) {\n            res.selected = true;\n            res.byKeyboard = true;\n        }\n        else {\n            const toCheck = owner ? [owner] : [_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right];\n            for (const playerSide of toCheck) {\n                if (this.pads.anyButtonsPushedBy(playerSide, ['psX'])) {\n                    res.selected = true;\n                    res.byPlayerSide = playerSide;\n                }\n            }\n        }\n        return res;\n    }\n    wasMenuLeftJustPushed(owner) {\n        if (this.keyboard.anyKeysJustPushed(['KeyA', 'KeyJ', 'ArrowLeft']))\n            return true;\n        if (owner) {\n            return this.pads.anyButtonsPushedBy(owner, ['dPadLeft']) || this.pads.wasThumbstickPushedLeftBy(owner, 'left');\n        }\n        else {\n            return this.pads.anyButtonsPushedByAnyone(['dPadLeft']) || this.pads.wasThumbstickPushedLeft('left');\n        }\n    }\n    wasMenuRightJustPushed(owner) {\n        if (this.keyboard.anyKeysJustPushed(['KeyD', 'KeyL', 'ArrowRight']))\n            return true;\n        if (owner) {\n            return this.pads.anyButtonsPushedBy(owner, ['dPadRight']) || this.pads.wasThumbstickPushedRightBy(owner, 'left');\n        }\n        else {\n            return this.pads.anyButtonsPushedByAnyone(['dPadRight']) || this.pads.wasThumbstickPushedRight('left');\n        }\n    }\n    wasMenuExitJustPushed(owner) {\n        if (owner)\n            return this.pads.anyButtonsPushedBy(owner, ['psO', 'start']);\n        else\n            return this.pads.anyButtonsPushedByAnyone(['psO', 'start']);\n    }\n    wasPostgameProceedJustPushed() {\n        return this.pads.anyButtonsPushedByAnyone(['psO', 'psX', 'start']) || this.wasMenuSelectJustPushed(null).selected;\n    }\n    wasPlayerJustDisconnectedFromGamepad(playerSide) {\n        return this.pads.wasPlayerJustDisconnected(playerSide);\n    }\n    wasPlayerJustConnectedToGamepad(playerSide) {\n        return this.pads.wasPlayerJustConnected(playerSide);\n    }\n    doesPlayerHaveGamepad(playerSide) {\n        return this.pads.doesPlayerHaveGamepad(playerSide);\n    }\n    gamepadConnectSummary() {\n        return {\n            left: this.pads.getStateFromPlayer(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left),\n            right: this.pads.getStateFromPlayer(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right),\n        };\n    }\n    isJumpPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        return this.keyboard.anyKeyDown(set.jump) || this.pads.anyButtonDown(pI, ['psX']);\n    }\n    /**\n     * returns 0 if trigger near 0, within tolerance\n     * defined in tweakables. otherwise returns value up to 1\n     */\n    getTrigger(playerSide, triggerName) {\n        const x = this.pads.getTrigger(playerSide, triggerName);\n        if (x < _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].input.triggerTolerance)\n            return 0;\n        return x;\n    }\n    /**\n     * returns 0 if thumbstick near the middle, within tolerance\n     * defined in tweakables. otherwise returns value\n     * @param playerSide - playerSide\n     */\n    getLeftThumbStickX(playerSide) {\n        const x = this.pads.getThumbStick(playerSide, 'left').x;\n        if (Math.abs(x) < _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].thumbstickCenterTolerance)\n            return 0;\n        else\n            return x;\n    }\n    isLeftPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        const keyboardLeft = this.keyboard.anyKeyDown(set.left) && !this.keyboard.anyKeyDown(set.right);\n        const dPadLeft = this.pads.anyButtonDown(pI, ['dPadLeft']);\n        return keyboardLeft || dPadLeft;\n    }\n    isRightPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        const keyboardRight = this.keyboard.anyKeyDown(set.right) && !this.keyboard.anyKeyDown(set.left);\n        const dPadRight = this.pads.anyButtonDown(pI, ['dPadRight']);\n        return keyboardRight || dPadRight;\n    }\n    isGrowPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        return this.keyboard.anyKeyDown(set.grow);\n    }\n    isShrinkPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        return this.keyboard.anyKeyDown(set.shrink);\n    }\n    wasDebugKeyJustPushed() {\n        return this.keyboard.anyKeysJustPushed(['KeyG']);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/input.ts?");

/***/ }),

/***/ "./src/kapow-manager.ts":
/*!******************************!*\
  !*** ./src/kapow-manager.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Kapow\": () => (/* binding */ Kapow),\n/* harmony export */   \"KapowManager\": () => (/* binding */ KapowManager),\n/* harmony export */   \"KapowType\": () => (/* binding */ KapowType)\n/* harmony export */ });\nvar KapowType;\n(function (KapowType) {\n    KapowType[\"Slam\"] = \"slam\";\n    KapowType[\"Rejected\"] = \"rejected\";\n    KapowType[\"Score\"] = \"score\";\n})(KapowType || (KapowType = {}));\nclass Kapow {\n    constructor(kapowType, pos, orientation, size, maxAge) {\n        this.age = 0;\n        this.kapowType = kapowType;\n        this.pos = pos;\n        this.orientation = orientation;\n        this.maxAge = maxAge;\n        this.size = size;\n    }\n    stepAndTestForDeath(dt) {\n        this.age += dt;\n        this.size += dt / 40;\n        return this.age >= this.maxAge;\n    }\n    fractionOfWayToDeath() {\n        return this.age / this.maxAge;\n    }\n}\nclass KapowManager {\n    constructor() {\n        this.kapows = new Array();\n    }\n    addAKapow(kapowType, pos, orientation, size, maxAge) {\n        this.kapows.push(new Kapow(kapowType, pos, orientation, size, maxAge));\n    }\n    step(dt) {\n        for (let i = this.kapows.length - 1; i >= 0; i--) {\n            if (this.kapows[i].stepAndTestForDeath(dt))\n                this.kapows.splice(i, 1);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/kapow-manager.ts?");

/***/ }),

/***/ "./src/keyboard-monitor.ts":
/*!*********************************!*\
  !*** ./src/keyboard-monitor.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KeyboardMonitor\": () => (/* binding */ KeyboardMonitor)\n/* harmony export */ });\nclass KeyboardMonitor {\n    constructor() {\n        this.keysDown = new Set();\n        this.prevKeysDown = new Set();\n        this.registerKeyboardActions();\n    }\n    update() {\n        this.prevKeysDown = new Set(this.keysDown);\n    }\n    isKeyDown(code) {\n        return this.keysDown.has(code);\n    }\n    anyKeyDown(codes) {\n        for (const c of codes) {\n            if (this.isKeyDown(c))\n                return true;\n        }\n        return false;\n    }\n    anyKeysJustPushed(codes) {\n        for (const c of codes) {\n            if (this.wasKeyJustPushed(c))\n                return true;\n        }\n        return false;\n    }\n    wasKeyJustPushed(code) {\n        if (!this.prevKeysDown)\n            return false;\n        const isPressed = this.keysDown.has(code);\n        const wasPressed = this.prevKeysDown.has(code);\n        if (this.prevKeysDown.size !== this.keysDown.size)\n            return isPressed && !wasPressed;\n        return false;\n    }\n    // ---- PRIVACY PLEASE\n    registerKeyboardActions() {\n        window.addEventListener('keydown', (event) => {\n            this.keysDown.add(event.code);\n        });\n        window.addEventListener('keyup', (event) => {\n            this.keysDown.delete(event.code);\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/keyboard-monitor.ts?");

/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Menu\": () => (/* binding */ Menu),\n/* harmony export */   \"MenuAction\": () => (/* binding */ MenuAction)\n/* harmony export */ });\n/* harmony import */ var _ai_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ai/ai */ \"./src/ai/ai.ts\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ \"./src/color.ts\");\n/* harmony import */ var _persistence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./persistence */ \"./src/persistence.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\n\n\n\n\nvar MenuAction;\n(function (MenuAction) {\n    MenuAction[\"ReturnToGame\"] = \"return-to-game\";\n    MenuAction[\"Play\"] = \"play\";\n    MenuAction[\"Exit\"] = \"exit\";\n})(MenuAction || (MenuAction = {}));\nconst allMenuItems = [\n    { text: 'Quit', action: MenuAction.Exit, card: 'menuCardExit' },\n    { text: 'Return to Game', action: MenuAction.ReturnToGame, card: 'menuCardReturnToGame' },\n    {\n        text: 'Human v. Human',\n        action: MenuAction.Play,\n        card: 'menuCardHuman1Ball',\n        opponentType: _player__WEBPACK_IMPORTED_MODULE_3__.PlayerSpecies.Human,\n        numBalls: 1,\n    },\n    {\n        text: 'Human v. Human',\n        action: MenuAction.Play,\n        card: 'menuCardHuman2Balls',\n        opponentType: _player__WEBPACK_IMPORTED_MODULE_3__.PlayerSpecies.Human,\n        numBalls: 2,\n    },\n    {\n        text: 'Challenge Green',\n        ai: _ai_ai__WEBPACK_IMPORTED_MODULE_0__.ais.Green,\n        action: MenuAction.Play,\n        card: 'menuCardPlayGreen',\n        opponentType: _player__WEBPACK_IMPORTED_MODULE_3__.PlayerSpecies.Ai,\n        numBalls: 1,\n    },\n    {\n        text: 'Challenge Purple',\n        ai: _ai_ai__WEBPACK_IMPORTED_MODULE_0__.ais.Purple,\n        action: MenuAction.Play,\n        card: 'menuCardPlayPurple',\n        opponentType: _player__WEBPACK_IMPORTED_MODULE_3__.PlayerSpecies.Ai,\n        numBalls: 2,\n        unlockRequirement: {\n            defeat: 'Green',\n            defeatType: 'win',\n        },\n    },\n    {\n        text: 'Challenge Black',\n        ai: _ai_ai__WEBPACK_IMPORTED_MODULE_0__.ais.Black,\n        action: MenuAction.Play,\n        card: 'menuCardPlayBlack',\n        opponentType: _player__WEBPACK_IMPORTED_MODULE_3__.PlayerSpecies.Ai,\n        numBalls: 1,\n        unlockRequirement: {\n            defeat: 'Purple',\n            defeatType: 'no-jumping',\n        },\n    },\n    {\n        text: 'Challenge White',\n        ai: _ai_ai__WEBPACK_IMPORTED_MODULE_0__.ais.White,\n        action: MenuAction.Play,\n        card: 'menuCardPlayWhite',\n        opponentType: _player__WEBPACK_IMPORTED_MODULE_3__.PlayerSpecies.Ai,\n        numBalls: 2,\n        unlockRequirement: {\n            defeat: 'Black',\n            defeatType: 'shutout',\n        },\n    },\n];\nclass Menu {\n    constructor(display) {\n        this.selectedMenuIndex = 2;\n        this.allowReturnToGame = true;\n        this.playerOwnsMenu = null; // If this is null, any controller can control menu.\n        this.display = display;\n        this.menuItems = allMenuItems;\n    }\n    get spriteBatch() {\n        return this.display.getSpriteBatch();\n    }\n    get selection() {\n        return this.menuItems[this.selectedMenuIndex].action;\n    }\n    get selectionEntry() {\n        return this.menuItems[this.selectedMenuIndex];\n    }\n    select(menuOption, playerSide) {\n        if (this.playerOwnsMenu === null || this.playerOwnsMenu === playerSide) {\n            for (let i = 0; i < this.menuItems.length; i++) {\n                if (this.menuItems[i].action === menuOption) {\n                    this.selectedMenuIndex = i;\n                    break;\n                }\n            }\n        }\n    }\n    isLockedReason(entry) {\n        if (entry.unlockRequirement) {\n            return this.lockCheckReason(entry.unlockRequirement);\n        }\n        return false;\n    }\n    /**\n     * returns false if not locked, otherwise a string explaining why\n     * @param ur\n     * @returns\n     */\n    lockCheckReason(ur) {\n        const d = _persistence__WEBPACK_IMPORTED_MODULE_2__.persistence.data.aiRecord[ur.defeat];\n        if (ur.defeatType === 'win') {\n            if (d.wins > 0)\n                return false;\n            else\n                return `defeat ${ur.defeat}`;\n        }\n        else if (ur.defeatType === 'no-jumping') {\n            if (d.noJumpWins > 0)\n                return false;\n            else\n                return `beat ${ur.defeat} without jumping`;\n        }\n        else if (ur.defeatType === 'shutout') {\n            if (d.shutoutWins > 0)\n                return false;\n            else\n                return `shut out ${ur.defeat}`;\n        }\n        else {\n            throw new Error(`unknown unlock requirement ${ur.defeatType}`);\n        }\n    }\n    action(num) {\n        return this.menuItems[num].action;\n    }\n    isOnLockedSelection() {\n        const sel = this.menuItems[this.selectedMenuIndex];\n        return this.isLockedReason(sel) ? true : false;\n    }\n    beat(totalSeconds) {\n        return 2.0 * Math.PI * totalSeconds * (_tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu.bpm / 60);\n    }\n    drawDancingMenuText(s, destination, totalSeconds, relSize) {\n        /* dancing stuff */\n        const beat = this.beat(totalSeconds);\n        const sizeMultiplier = 0.3 + Math.sin(beat / 2) / 100 + Math.sin(beat / 8) / 100;\n        const size = sizeMultiplier * relSize;\n        const rotation = -0.1 + Math.sin(beat / 16) / 32;\n        const backgroundColor = new _color__WEBPACK_IMPORTED_MODULE_1__.Color(0.0, 0.0, 0.0, 0.75);\n        const backgroundColor2 = new _color__WEBPACK_IMPORTED_MODULE_1__.Color(0.0, 0.0, 0.0, 0.15);\n        const foregroundColor = _color__WEBPACK_IMPORTED_MODULE_1__.Colors.white;\n        const p0 = _utils__WEBPACK_IMPORTED_MODULE_5__.vec.add(destination, { x: -0.01, y: -0.01 });\n        const p1 = _utils__WEBPACK_IMPORTED_MODULE_5__.vec.add(destination, { x: 0.01, y: 0.02 });\n        const p2 = destination;\n        const font = this.display.font('extraBold');\n        this.spriteBatch.drawStringCentered(s, font, size, p0, backgroundColor2, rotation);\n        this.spriteBatch.drawStringCentered(s, font, size, p1, backgroundColor, rotation);\n        this.spriteBatch.drawStringCentered(s, font, size, p2, foregroundColor, rotation);\n    }\n    /**\n     * returns -2 if this card is 2 to the left of the currently selected card\n     */\n    cardOffset(i) {\n        return i - this.selectedMenuIndex;\n    }\n    cardCenter(i) {\n        const tMenu = _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu;\n        const offset = this.cardOffset(i);\n        const offsetDir = offset ? (0,_utils__WEBPACK_IMPORTED_MODULE_5__.sign)(offset) : 0;\n        const offsetCurve = offset ? (0,_utils__WEBPACK_IMPORTED_MODULE_5__.sign)(offset) * Math.sqrt(Math.abs(offset)) : 0;\n        return {\n            x: tMenu.cardStackStart.x + tMenu.cardStackSpacing.x * offsetCurve + offsetDir * tMenu.afterChosenOffset.x,\n            y: tMenu.cardStackStart.y + Math.abs(tMenu.cardStackSpacing.y * offsetCurve) + tMenu.afterChosenOffset.y,\n        };\n    }\n    cardWidth(gameTime, i) {\n        const beat = this.beat(gameTime.totalGameTime.totalSeconds);\n        const bounce = _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu.cardSizeBounce;\n        const sizeMultiplier = Math.sin(beat / 8) * bounce + Math.sin(beat / 32) * bounce;\n        const offset = this.cardOffset(i);\n        if (offset === 0)\n            return _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu.cardWidthSelected * (1 - sizeMultiplier);\n        return _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu.cardWidth * (1 + sizeMultiplier);\n    }\n    cardRotation(gameTime, i) {\n        const beat = this.beat(gameTime.totalGameTime.totalSeconds) + i;\n        const bounce = _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu.cardRotationBounce;\n        const rot = Math.sin(beat / 16) * bounce + Math.sin(beat / 64) * bounce;\n        const offset = this.cardOffset(i);\n        if (offset === 0)\n            return rot;\n        return -rot;\n    }\n    drawCard(i, center, isSelected, gameTime) {\n        const tMenu = _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu;\n        const item = this.menuItems[i];\n        const cardWidth = this.cardWidth(gameTime, i);\n        const texture = this.display.getTexture(item.card);\n        const dims = this.spriteBatch.autoDim(cardWidth, texture);\n        const rotation = this.cardRotation(gameTime, i);\n        const shadowTexture = this.display.getTexture('menuCardShadow');\n        const lockOverlay = this.display.getTexture('menuCardLockOverlay');\n        const sCenter = _utils__WEBPACK_IMPORTED_MODULE_5__.vec.add(center, { x: 0.03, y: -0.03 });\n        const lockReason = this.isLockedReason(item);\n        const cosRot = Math.cos(rotation); // useful for attachments\n        const relPos = (v) => ({\n            x: center.x + ((cosRot * dims.w) / 2) * v.x,\n            y: center.y + ((cosRot * dims.h) / 2) * v.y,\n        });\n        // shadow\n        this.spriteBatch.drawTextureCentered(shadowTexture, sCenter, dims, rotation, 1);\n        // then the card itself\n        this.spriteBatch.drawTextureCentered(texture, center, dims, rotation, 1);\n        // now any attachments, such as #ball icons, etc.\n        const ballSize = cardWidth * tMenu.cardBallSize;\n        const ball1Pos = relPos(tMenu.cardBall1Pos);\n        const ball2Pos = relPos(tMenu.cardBall2Pos);\n        const ball1Texture = this.display.getTexture('ball1');\n        const ball2Texture = this.display.getTexture('ball2');\n        const ballRot = isSelected ? gameTime.totalGameTime.totalSeconds : rotation;\n        if (item.numBalls === 1) {\n            this.spriteBatch.drawTextureCentered(ball1Texture, ball1Pos, { w: ballSize, h: ballSize }, ballRot, 1);\n        }\n        if (item.numBalls === 2) {\n            this.spriteBatch.drawTextureCentered(ball1Texture, ball2Pos, { w: ballSize, h: ballSize }, ballRot, 1);\n            this.spriteBatch.drawTextureCentered(ball2Texture, ball1Pos, { w: ballSize, h: ballSize }, ballRot, 1);\n        }\n        // then lock overlay, if it's locked\n        if (lockReason) {\n            this.spriteBatch.drawTextureCentered(lockOverlay, center, dims, rotation, tMenu.lockOverlayAlpha);\n            if (isSelected) {\n                const txtCenter = relPos(tMenu.lockReasonPos);\n                const txtCenter2 = relPos({ x: 0, y: -0 });\n                const font = this.display.font('regular');\n                this.spriteBatch.drawStringCentered(lockReason, font, 0.04, txtCenter, tMenu.lockReasonColor, rotation);\n                this.spriteBatch.drawStringCentered('LOCKED', font, 0.06, txtCenter2, tMenu.lockReasonColor, rotation);\n            }\n        }\n        // Draw the dancing text if it is currently selected\n        const seconds = gameTime.totalGameTime.totalSeconds;\n        if (isSelected && !lockReason) {\n            const textCenter = _utils__WEBPACK_IMPORTED_MODULE_5__.vec.add(center, tMenu.textOffsetFromCard);\n            const subtext = item.subtext;\n            if (subtext) {\n                const pos = _utils__WEBPACK_IMPORTED_MODULE_5__.vec.add(textCenter, tMenu.subtextOffset);\n                this.drawDancingMenuText(subtext, pos, seconds + 1, tMenu.subtextRelSize);\n            }\n            this.drawDancingMenuText(item.text, textCenter, seconds, 1);\n        }\n        const ai = item.ai;\n        if (isSelected && ai && !lockReason) {\n            this.drawCardStats(item, ai);\n        }\n    }\n    drawCardStatLine(sL, sR, pos, isBad) {\n        const tMenu = _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu;\n        const colL = tMenu.statsColorLeft;\n        const colR = isBad ? tMenu.statsColorRightBad : tMenu.statsColorRight;\n        const sizeL = tMenu.statsFontSize;\n        const sizeR = sizeL * tMenu.statsRightColFontMult;\n        const fontL = this.display.font('regular');\n        const fontR = this.display.font('extraBold');\n        const drawOptsL = { textAlign: 'right' };\n        const drawOptsR = { textAlign: 'left' };\n        const posR = _utils__WEBPACK_IMPORTED_MODULE_5__.vec.add(pos, tMenu.statsRightColAdj);\n        this.spriteBatch.drawStringUncentered(sL, fontL, sizeL, pos, colL, 0, drawOptsL);\n        this.spriteBatch.drawStringUncentered(sR, fontR, sizeR, posR, colR, 0, drawOptsR);\n    }\n    drawCardStats(item, ai) {\n        var _a;\n        // Stats at the bottom\n        const tMenu = _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu;\n        const pos = _utils__WEBPACK_IMPORTED_MODULE_5__.vec.copy(tMenu.statsPosition);\n        const record = _persistence__WEBPACK_IMPORTED_MODULE_2__.persistence.data.aiRecord[(0,_ai_ai__WEBPACK_IMPORTED_MODULE_0__.aiToName)(ai)];\n        const fastestWin = (_a = record.fastestWin) !== null && _a !== void 0 ? _a : Infinity;\n        const lSpace = tMenu.statsFontSize * tMenu.statsLineSpacing;\n        this.drawCardStatLine(`wins:`, `${record.wins}`, pos, record.wins < 1);\n        if (record.wins) {\n            pos.y -= lSpace;\n            this.drawCardStatLine(`shutouts:`, `${record.shutoutWins}`, pos, record.shutoutWins < 1);\n            pos.y -= lSpace;\n            this.drawCardStatLine(`no jump wins:`, `${record.noJumpWins}`, pos, record.noJumpWins < 1);\n            pos.y -= lSpace;\n            let emoji = '';\n            for (const time of tMenu.statsFastestWinFlames) {\n                if (fastestWin < time)\n                    emoji += '';\n            }\n            this.drawCardStatLine(`fastest win:`, `${fastestWin.toFixed(3)} ${emoji}`, pos, fastestWin > 60);\n        }\n        pos.y -= lSpace;\n        this.drawCardStatLine(`games played:`, `${record.wins + record.losses}`, pos, false);\n    }\n    draw(allowReturnToGame, gameTime) {\n        this.allowReturnToGame = allowReturnToGame;\n        if (!allowReturnToGame && this.selection === MenuAction.ReturnToGame) {\n            this.moveRight(this.playerOwnsMenu);\n        }\n        const tMenu = _tweakables__WEBPACK_IMPORTED_MODULE_4__[\"default\"].menu;\n        // draw a cover over the existing game\n        this.spriteBatch.drawScreenOverlay(tMenu.coverColor);\n        // TODO: see if this is slow; menu is pretty msall\n        const drawOrder = Object.keys(this.menuItems).sort((a, b) => Math.abs(this.cardOffset(parseInt(b))) - Math.abs(this.cardOffset(parseInt(a))));\n        for (const k of drawOrder) {\n            const i = parseInt(k);\n            if (this.action(i) === MenuAction.ReturnToGame && !this.allowReturnToGame)\n                continue;\n            const center = this.cardCenter(i);\n            if (i === this.selectedMenuIndex) {\n                // draw a second cover over the non-selected ones\n                this.spriteBatch.drawScreenOverlay(tMenu.deselectedCardColor);\n                this.drawCard(i, center, true, gameTime);\n            }\n            else {\n                this.drawCard(i, center, false, gameTime);\n            }\n        }\n    }\n    getCard(menuItem) {\n        return this.display.getTexture(this.menuItems[menuItem].card);\n    }\n    moveRight(owner) {\n        if (this.playerOwnsMenu === null || this.playerOwnsMenu === owner) {\n            this.selectedMenuIndex = (this.selectedMenuIndex + 1) % this.menuItems.length;\n            if (this.selection === MenuAction.ReturnToGame && !this.allowReturnToGame) {\n                this.selectedMenuIndex++;\n            }\n        }\n    }\n    moveLeft(owner) {\n        if (this.playerOwnsMenu === null || this.playerOwnsMenu === owner) {\n            this.selectedMenuIndex--;\n            if (this.selectedMenuIndex >= 0 && this.selection === MenuAction.ReturnToGame && !this.allowReturnToGame) {\n                this.selectedMenuIndex--;\n            }\n            if (this.selectedMenuIndex < 0) {\n                this.selectedMenuIndex = this.menuItems.length - 1;\n            }\n        }\n    }\n    getWhoOwnsMenu() {\n        return this.playerOwnsMenu;\n    }\n    setWhoOwnsMenu(playerSide) {\n        this.playerOwnsMenu = playerSide;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/menu.ts?");

/***/ }),

/***/ "./src/page-ui.ts":
/*!************************!*\
  !*** ./src/page-ui.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PageUi\": () => (/* binding */ PageUi)\n/* harmony export */ });\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass PageUi {\n    constructor(parentEl) {\n        this.runYet = false;\n        this.parentEl = parentEl;\n        this.generateLayout();\n        const canvasWrapper = this.findDiv('#game-canvas-wrapper');\n        this.game = new _game__WEBPACK_IMPORTED_MODULE_0__.Game(canvasWrapper, (s) => this.contentLoadMonitor(s));\n    }\n    lPad(n, len) {\n        let s = `${n}`;\n        while (s.length < len)\n            s = `0${s}`;\n        return s;\n    }\n    contentLoadMonitor(s) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const $el = document.getElementById('load-stats');\n            const w = 100;\n            const leftW = 1 + (s.done / s.total) * w;\n            const rightW = 1 + w - leftW;\n            let text = `${s.done === s.total ? '' : ''} ${this.lPad(s.done, 3)}/${s.total} textures &amp; sounds.`;\n            if (this.runYet)\n                text = 'Almost there...will launch when loaded';\n            if ($el)\n                $el.innerHTML = `\n    <div style=\"display:inline-block;width:${leftW}px;height:11px;background-color:#00f\"></div><div style=\"display:inline-block;width:${rightW}px;height:10px;background-color:#eee\"></div>\n    ${text}\n    `;\n            if (s.done === s.total) {\n                const launchInst = document.getElementById('launch-instructions');\n                while (!this.runYet) {\n                    launchInst.innerHTML = '&nbsp;';\n                    yield (0,_utils__WEBPACK_IMPORTED_MODULE_1__.timeout)(500);\n                    launchInst.innerHTML = `Press <b>[spacebar]</b> to play.`;\n                    yield (0,_utils__WEBPACK_IMPORTED_MODULE_1__.timeout)(1500);\n                }\n            }\n        });\n    }\n    // -----------------------------------------------------------\n    // PRIVATE\n    // -----------------------------------------------------------\n    findDiv(selectors) {\n        return this.parentEl.querySelector(selectors);\n    }\n    onRunClick() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.runYet) {\n                const btn = document.getElementById('btn-go');\n                if (btn) {\n                    btn.style.display = 'none';\n                }\n                document.body.classList.add('in-game');\n                this.runYet = true;\n                yield this.game.run();\n                // game is over\n                this.refresh();\n            }\n        });\n    }\n    // -----------------------------------------------------------\n    refresh() {\n        // TODO: something that doesn't require rechecking all the assets\n        // for not-modified\n        window.location.reload();\n    }\n    // -----------------------------------------------------------\n    isMobile() {\n        if (/iPad|Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    // -----------------------------------------------------------\n    introDiv() {\n        const mobileMessage = this.isMobile()\n            ? `\n      <div style=\"text-align:center;font-size:2em;margin-top:40px;\">\n          <b>T.C.F.T.G</b> will play on an <b>iPad</b>, but only with an\n         external keyboard. It will not play on phones.\n        </p>\n      </div>\n    `\n            : '';\n        return `    <div class=\"game-intro-wrapper\">\n    <div class=\"intro-note\" style=\"max-width:100%;\">\n      <div style=\"text-align:center\">\n        <img src=\"/images/site/cover.png\" width=\"100%\">\n        <div id=\"load-stats\" style=\"text-align:center;font-size:0.9em;height:14px;\"></div>\n        ${mobileMessage}        \n        <div id=\"launch-instructions\"  style=\"text-align:center;font-size:1.1em;height:20px;margin-top:20px;\"></div>\n      </div>\n      <h4 style=\"margin-top:50px;\">Controls & notes</h4>\n      <p>\n      : T.C.F.T.G. works with 1 or 2 gamepads. (PS5, XBox, etc. controllers work when plugged into your computer.)\n      <br><br>\n      If you're using a keyboard:\n      <br><br>\n        Player 1 : <b>a w d</b> to move\n      <br>\n        Player 2 : <b>i j l</b> or <b>arrow keys</b>\n      </p>\n      <h4>Latest changes</h4>\n      <p>\n      Toying with friction and spin on the balls\n      </p>\n      <h4>Links</h4>\n      <ul>\n       <li><a href=\"https://github.com/malgorithms/they-came-from-the-ground\">source code</a></li>\n       <li><a href=\"#no\" id=\"btn-erase-storage\">erase local stats</a></li>\n       <li>my personal website, <a href=\"https://chriscoyne.com\">ChrisCoyne.com</a></li>\n       <li>my twitter, <a href=\"https://twitter.com/malgorithms\">@malgorithms</a></li>\n      </ul>\n      <h4>About</h4>\n      <p>\n        This game is a free, open-source hobby project by <b>Chris Coyne</b> (<a href=\"https://chriscoyne.com\">chriscoyne.com</a>) with help from friends. The GitHub readme shows how to run your own\n        copy of the game. It's a joy to change the game physics and rules. The original inspiration for this game was Slime Volleyball, by Quin Pendragon. Music in T.C.F.T.G. by my friend\n        Christian Rudder, of the band <a href=\"https://en.wikipedia.org/wiki/Bishop_Allen\">Bishop Allen</a>.\n      </p>\n      </div>\n    </div>`;\n    }\n    generateLayout() {\n        this.parentEl.innerHTML = `\n    <div class=\"world-container\">\n        <div id=\"game-canvas-wrapper\">\n        ${this.introDiv()}\n        </div>\n    </div>`;\n        const loaded = Date.now();\n        // in Chrome, we need to trigger anything audio related by user action, or it won't play.\n        window.onkeydown = (e) => {\n            if (Date.now() - loaded > 100 && e.key === ' ') {\n                this.onRunClick();\n            }\n        };\n        const btn = document.getElementById('btn-go');\n        if (btn)\n            btn.onclick = () => this.onRunClick();\n        const eraseBtn = document.getElementById('btn-erase-storage');\n        eraseBtn.onclick = () => {\n            if (confirm('sure? this will clear your game stats and unlocks.')) {\n                window.localStorage.clear();\n                alert('done!');\n                this.refresh();\n            }\n        };\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/page-ui.ts?");

/***/ }),

/***/ "./src/persistence.ts":
/*!****************************!*\
  !*** ./src/persistence.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"persistence\": () => (/* binding */ persistence)\n/* harmony export */ });\n/* harmony import */ var _ai_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ai/ai */ \"./src/ai/ai.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/**\n *  This class is for maintaining state across multiple plays of the game\n *  in the same browser.\n *\n *  One thing we want to be careful of is the player having 2 tabs open at once with the\n *  game. If they unlock something in one, we wouldn't want them to lose it in the other by\n *  the second overwriting local storage. So we should try to increment values\n *  in the local store and then always use that as a source of truth, not what's in memory\n */\n\n\n\nclass Persistence {\n    constructor() {\n        this.writeData(this.data);\n        const hoursAgo = (Date.now() - this.data.firstPlayed) / 3600000;\n        const d = this.data;\n        console.log(`You have played T.C.F.T.G. ${d.games.completed} time(s) in the last ${hoursAgo.toFixed(1)} hours`);\n        console.log(this.data);\n        this.log('ready to play.');\n    }\n    get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n        let o = {};\n        try {\n            const str = window.localStorage.getItem('gameData');\n            o = JSON.parse(str !== null && str !== void 0 ? str : '{}');\n        }\n        catch (err) {\n            console.error(err);\n        }\n        const data = {\n            gameVersion: (_a = o.gameVersion) !== null && _a !== void 0 ? _a : _constants__WEBPACK_IMPORTED_MODULE_1__[\"default\"].version,\n            firstPlayed: (_b = o.firstPlayed) !== null && _b !== void 0 ? _b : Date.now(),\n            lastPlayed: (_c = o.lastPlayed) !== null && _c !== void 0 ? _c : Date.now(),\n            games: {\n                started: (_e = (_d = o.games) === null || _d === void 0 ? void 0 : _d.started) !== null && _e !== void 0 ? _e : 0,\n                completed: (_g = (_f = o.games) === null || _f === void 0 ? void 0 : _f.completed) !== null && _g !== void 0 ? _g : 0,\n            },\n            aiRecord: this.emptyAiRecord(),\n            playerId: (_h = o.playerId) !== null && _h !== void 0 ? _h : this.randomPlayerId(),\n        };\n        const prevRecord = o.aiRecord || {};\n        for (const aiName of _ai_ai__WEBPACK_IMPORTED_MODULE_0__.aiNames) {\n            data.aiRecord[aiName] = {\n                wins: (_k = (_j = prevRecord[aiName]) === null || _j === void 0 ? void 0 : _j.wins) !== null && _k !== void 0 ? _k : 0,\n                losses: (_m = (_l = prevRecord[aiName]) === null || _l === void 0 ? void 0 : _l.losses) !== null && _m !== void 0 ? _m : 0,\n                shutoutWins: (_p = (_o = prevRecord[aiName]) === null || _o === void 0 ? void 0 : _o.shutoutWins) !== null && _p !== void 0 ? _p : 0,\n                noJumpWins: (_r = (_q = prevRecord[aiName]) === null || _q === void 0 ? void 0 : _q.noJumpWins) !== null && _r !== void 0 ? _r : 0,\n                fastestWin: (_t = (_s = prevRecord[aiName]) === null || _s === void 0 ? void 0 : _s.fastestWin) !== null && _t !== void 0 ? _t : null,\n            };\n        }\n        return data;\n    }\n    writeData(d) {\n        window.localStorage.setItem('gameData', JSON.stringify(d));\n    }\n    incGamesStarted(numBalls, species, aiName) {\n        this.log(`game started. numBalls=${numBalls}, species=${species}, ai=${aiName || ''}`);\n        const d = this.data;\n        const now = Date.now();\n        d.lastPlayed = now;\n        d.games.started++;\n        this.writeData(d);\n    }\n    incGamesCompleted() {\n        this.log('game complete.');\n        const d = this.data;\n        d.lastPlayed = Date.now();\n        d.games.completed++;\n        this.writeData(d);\n    }\n    recordResultAgainstAi(aiName, win, shutoutWin, seconds, jumpCount) {\n        this.log(`ai result. against=${aiName} win=${win} shutout=${shutoutWin} seconds=${seconds} jumps=${jumpCount}`);\n        const d = this.data;\n        const record = d.aiRecord[aiName];\n        console.log({ aiName, win, shutoutWin, seconds, jumpCount });\n        if (win) {\n            record.wins++;\n            if (shutoutWin)\n                record.shutoutWins++;\n            if (!jumpCount)\n                record.noJumpWins++;\n            if (!record.fastestWin || seconds < record.fastestWin)\n                record.fastestWin = seconds;\n        }\n        else {\n            record.losses++;\n        }\n        console.log(`About to write`, JSON.stringify(d, null, 2));\n        console.log(`Before write:`, JSON.stringify(this.data, null, 2));\n        this.writeData(d);\n        console.log(`After write:`, JSON.stringify(this.data, null, 2));\n    }\n    emptyAiRecord() {\n        const res = {};\n        for (const aiName of _ai_ai__WEBPACK_IMPORTED_MODULE_0__.aiNames) {\n            res[aiName] = { wins: 0, losses: 0, shutoutWins: 0, noJumpWins: 0, fastestWin: null };\n        }\n        return res;\n    }\n    randomPlayerId() {\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_2__.randomByteHexString)(16);\n    }\n    log(text) {\n        const msg = { action: 'log', playerId: this.data.playerId, text };\n        const post = JSON.stringify(msg);\n        const url = '/api/persistence';\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', url, true);\n        xhr.setRequestHeader('Content-type', 'application/json; charset=UTF-8');\n        xhr.send(post);\n        xhr.onload = () => {\n            if (xhr.status === 201)\n                console.log(`log: ${text}`);\n        };\n    }\n}\nconst persistence = new Persistence();\n\n\n\n//# sourceURL=webpack:///./src/persistence.ts?");

/***/ }),

/***/ "./src/player.ts":
/*!***********************!*\
  !*** ./src/player.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => (/* binding */ Player),\n/* harmony export */   \"PlayerSpecies\": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_2__.PlayerSpecies)\n/* harmony export */ });\n/* harmony import */ var _circular_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circular-object */ \"./src/circular-object.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\n\n\nclass Player {\n    constructor(o) {\n        this._jumpCount = 0;\n        this._isInJumpPosition = false;\n        this.physics = new _circular_object__WEBPACK_IMPORTED_MODULE_0__.CircularObject(_utils__WEBPACK_IMPORTED_MODULE_3__.vec.zero(), _utils__WEBPACK_IMPORTED_MODULE_3__.vec.zero(), o.diameter, o.mass, 0, 0, o.gravityMultiplier, false, 0, 0);\n        this.maxVel = o.maxVel;\n        this.targetXVel = o.targetXVel;\n        this.xSpringConstant = o.xSpringConstant;\n        this.species = o.species;\n        this.ai = o.ai;\n    }\n    get jumpCount() {\n        return this._jumpCount;\n    }\n    get isInJumpPosition() {\n        return this._isInJumpPosition;\n    }\n    setIsInJumpPosition(canJump) {\n        this._isInJumpPosition = canJump;\n    }\n    deepCopy() {\n        const sp = new Player({\n            maxVel: _utils__WEBPACK_IMPORTED_MODULE_3__.vec.copy(this.maxVel),\n            diameter: this.physics.diameter,\n            mass: this.physics.mass,\n            xSpringConstant: this.xSpringConstant,\n            gravityMultiplier: this.physics.gravityMultiplier,\n            targetXVel: this.targetXVel,\n            species: this.species,\n            ai: this.ai,\n        });\n        sp.physics.center = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.copy(this.physics.center);\n        sp.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.copy(this.physics.vel);\n        sp.physics.orientation = this.physics.orientation;\n        sp.physics.angularVel = this.physics.angularVel;\n        sp._jumpCount = this._jumpCount;\n        return sp;\n    }\n    jump() {\n        if (this.isInJumpPosition) {\n            this._jumpCount++;\n            this.physics.vel.y = this.maxVel.y;\n        }\n    }\n    grow(dt, vel) {\n        const oldDiameter = this.physics.diameter;\n        this.physics.diameter += vel * dt;\n        if (this.physics.diameter < _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.minDiameter)\n            this.physics.diameter = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.minDiameter;\n        if (this.physics.diameter > _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.maxDiameter)\n            this.physics.diameter = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.maxDiameter;\n        const ratio = oldDiameter / this.physics.diameter;\n        this.maxVel.x *= Math.sqrt(ratio);\n        this.maxVel.y *= Math.sqrt(Math.sqrt(ratio));\n        this.physics.mass *= (1 / ratio) * (1 / ratio);\n    }\n    moveRight() {\n        this.targetXVel = this.maxVel.x;\n    }\n    moveLeft() {\n        this.targetXVel = -this.maxVel.x;\n    }\n    moveRationally(fractionOfMaxVelocity) {\n        this.targetXVel = this.maxVel.x * fractionOfMaxVelocity;\n    }\n    stepPosition(dt) {\n        this.physics.center = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.add(this.physics.center, _utils__WEBPACK_IMPORTED_MODULE_3__.vec.scale(this.physics.vel, dt));\n    }\n    stepVelocity(dt, gravity) {\n        const idealVx = this.targetXVel * this.maxVel.x;\n        const difference = idealVx - this.physics.vel.x;\n        this.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.add(this.physics.vel, { x: difference * dt * this.xSpringConstant, y: 0 });\n        // gravity\n        this.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.add(this.physics.vel, _utils__WEBPACK_IMPORTED_MODULE_3__.vec.scale(gravity, dt * this.physics.gravityMultiplier));\n    }\n    isOnHeight(height) {\n        return this.physics.center.y <= height + _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].proximityTolerance;\n    }\n    isOnPlayer(opponent) {\n        // Jump off opponent! Are you serious?! Yes.\n        const diff = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.sub(this.physics.center, opponent.physics.center);\n        const distance = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.len(diff);\n        if (distance < this.physics.diameter / 2 + opponent.physics.diameter / 2 + _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].proximityTolerance) {\n            // Only if above opponent\n            if (this.physics.center.y > opponent.physics.center.y) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isOnRectangle(obstacle) {\n        // top-left corner\n        const netTopLeftCorner = { x: obstacle.center.x - obstacle.width / 2, y: obstacle.center.y + obstacle.height / 2 };\n        const distToNetTopLeft = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.len(_utils__WEBPACK_IMPORTED_MODULE_3__.vec.sub(netTopLeftCorner, this.physics.center));\n        if (distToNetTopLeft <= this.physics.diameter / 2 + _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].proximityTolerance) {\n            return true;\n        }\n        // top-right corner\n        const netTopRightCorner = { x: obstacle.center.x + obstacle.width / 2, y: obstacle.center.y + obstacle.height / 2 };\n        const distToNetTopRight = _utils__WEBPACK_IMPORTED_MODULE_3__.vec.len(_utils__WEBPACK_IMPORTED_MODULE_3__.vec.sub(netTopRightCorner, this.physics.center));\n        if (distToNetTopRight <= this.physics.diameter / 2 + _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].proximityTolerance) {\n            return true;\n        }\n        // top of it\n        if (this.physics.center.x > obstacle.center.x - obstacle.width / 2 && this.physics.center.x < obstacle.center.x + obstacle.width / 2) {\n            const jumpHeight = obstacle.center.y + obstacle.height / 2 + this.physics.diameter / 2;\n            if (this.isOnHeight(jumpHeight)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getMaxJumpHeight(gameGravityY) {\n        return (this.maxVel.y * this.maxVel.y) / (2 * Math.abs(gameGravityY * this.physics.gravityMultiplier));\n    }\n    getTimeToJumpToHeight(gameGravityY, height) {\n        // y = y0 + v0t + 0.5at^2\n        // y = 0 + vt + 0.5gt^2\n        // 0.5gt^2 + vt - y = 0\n        // (-v +- sqrt(v*v+2yg) ) / (g)\n        const g = gameGravityY * this.physics.gravityMultiplier;\n        const v = this.maxVel.y;\n        if (v * v + 2 * height * g < 0)\n            return Infinity;\n        else {\n            const answer1 = (-v + Math.sqrt(v * v + 2 * height * g)) / g;\n            const answer2 = (-v - Math.sqrt(v * v + 2 * height * g)) / g;\n            if (answer1 > 0 && answer2 > 0 && answer1 < answer2)\n                return answer1;\n            else if (answer1 > 0 && answer2 > 0 && answer2 < answer1)\n                return answer2;\n            else if (answer2 > 0)\n                return answer2;\n            else if (answer1 > 0)\n                return answer1;\n            else\n                return Infinity;\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/player.ts?");

/***/ }),

/***/ "./src/rectangular-obstacle.ts":
/*!*************************************!*\
  !*** ./src/rectangular-obstacle.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RectangularObstacle\": () => (/* binding */ RectangularObstacle)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\nclass RectangularObstacle {\n    constructor(o) {\n        this.center = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.copy(o.center);\n        this.width = o.width;\n        this.height = o.height;\n    }\n    handleBallCollision(ball, elasticity, isSimulation) {\n        let didCollide = false;\n        const ballRad = ball.diameter / 2;\n        const cx = this.center.x;\n        const cy = this.center.y;\n        const bx = ball.center.x;\n        const by = ball.center.y;\n        const cLt = cx - this.width / 2;\n        const cRt = cx + this.width / 2;\n        const cUp = cy + this.height / 2;\n        const cDw = cy - this.height / 2;\n        if (bx + ballRad < cLt)\n            return false;\n        if (bx - ballRad > cRt)\n            return false;\n        if (by - ballRad > cUp)\n            return false;\n        if (by + ballRad < cDw)\n            return false;\n        didCollide || (didCollide = ball.handleHittingVerticalSegment({ x: cLt, y: cDw }, { x: cLt, y: cUp }, elasticity, isSimulation));\n        didCollide || (didCollide = ball.handleHittingHorizontalSegment({ x: cLt, y: cUp }, { x: cRt, y: cUp }, elasticity, isSimulation));\n        didCollide || (didCollide = ball.handleHittingVerticalSegment({ x: cRt, y: cDw }, { x: cRt, y: cUp }, elasticity, isSimulation));\n        didCollide || (didCollide = ball.handleHittingHorizontalSegment({ x: cLt, y: cDw }, { x: cRt, y: cDw }, elasticity, isSimulation));\n        didCollide || (didCollide = ball.handleHittingPoint({ x: cLt, y: cDw }, elasticity, isSimulation));\n        didCollide || (didCollide = ball.handleHittingPoint({ x: cLt, y: cUp }, elasticity, isSimulation));\n        didCollide || (didCollide = ball.handleHittingPoint({ x: cRt, y: cUp }, elasticity, isSimulation));\n        didCollide || (didCollide = ball.handleHittingPoint({ x: cRt, y: cDw }, elasticity, isSimulation));\n        return didCollide;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/rectangular-obstacle.ts?");

/***/ }),

/***/ "./src/score-card.ts":
/*!***************************!*\
  !*** ./src/score-card.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScoreCard\": () => (/* binding */ ScoreCard)\n/* harmony export */ });\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n\nconst { scoreCard } = _tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nclass ScoreCard {\n    constructor() {\n        this.sizeMultiplier = scoreCard.sizeMultiplier;\n        this.sizeVelocity = scoreCard.sizeVelocity;\n        this.springConstant = scoreCard.springConstant;\n        this.dampeningConstant = scoreCard.dampeningConstant;\n        this.bounceVelocity = scoreCard.bounceVelocity;\n        this.minSizeMultiplier = scoreCard.minSizeMultiplier;\n        this.maxSizeMultiplier = scoreCard.maxSizeMultiplier;\n    }\n    update(dt) {\n        const force = (1.0 - this.sizeMultiplier) * this.springConstant - this.sizeVelocity * this.dampeningConstant;\n        this.sizeVelocity += force * dt;\n        this.sizeMultiplier += this.sizeVelocity * dt;\n        if (this.sizeMultiplier < this.minSizeMultiplier)\n            this.sizeMultiplier = this.minSizeMultiplier;\n        else if (this.sizeMultiplier > this.maxSizeMultiplier)\n            this.sizeMultiplier = this.maxSizeMultiplier;\n    }\n    bounce() {\n        this.sizeVelocity = this.bounceVelocity;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/score-card.ts?");

/***/ }),

/***/ "./src/sound-effect.ts":
/*!*****************************!*\
  !*** ./src/sound-effect.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundEffect\": () => (/* binding */ SoundEffect)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass SoundEffect {\n    constructor(audioBuffer, audioContext) {\n        this.playingSources = new Array();\n        this.audioBuffer = audioBuffer;\n        this.audioContext = audioContext;\n    }\n    get isPlaying() {\n        return this.playingSources.length > 0;\n    }\n    play(volume, pitch, pan, loop) {\n        const source = this.audioContext.createBufferSource();\n        const currTime = this.audioContext.currentTime;\n        source.buffer = this.audioBuffer;\n        // connect buffer -> gain node -> panner node -> pitch node -> destination\n        const gainNode = this.audioContext.createGain();\n        const pannerNode = this.audioContext.createStereoPanner();\n        if (volume < 0 || volume > 1)\n            throw new Error(`bad volume ${volume}`);\n        if (pan < -1 || pan > 1)\n            throw new Error(`bad pan ${pan}`);\n        if (pitch < -1 || pitch > 1)\n            throw new Error(`bad pitch ${pitch}`);\n        gainNode.gain.linearRampToValueAtTime(volume, currTime);\n        pannerNode.pan.setValueAtTime(pan, 0);\n        // attempt to change pitch. pitch values comes in -1...1\n        let rate = source.playbackRate.value;\n        rate = rate * 1 + pitch / 2;\n        source.playbackRate.setValueAtTime(rate, 0);\n        // connections\n        source.connect(gainNode);\n        gainNode.connect(pannerNode);\n        pannerNode.connect(this.audioContext.destination);\n        source.loop = loop;\n        this.playingSources.push(source);\n        source.start(0, 0);\n        source.onended = () => {\n            this.playingSources.splice(this.playingSources.indexOf(source), 1);\n        };\n        return {\n            source: source,\n            stop: () => this.stopSource(source),\n            gainNode: gainNode,\n            effect: this,\n            fadeOut: (seconds) => this.fadeOutSource(seconds, gainNode, source),\n        };\n    }\n    stopIfPlaying() {\n        for (const s of this.playingSources) {\n            s.stop();\n        }\n        this.playingSources = [];\n    }\n    fadeOutSource(seconds, gainNode, source) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currTime = this.audioContext.currentTime;\n            gainNode.gain.linearRampToValueAtTime(0, currTime + seconds);\n            yield (0,_utils__WEBPACK_IMPORTED_MODULE_0__.timeout)(seconds);\n            source.stop();\n        });\n    }\n    stopSource(source) {\n        source.stop();\n        this.playingSources = this.playingSources.filter((s) => s !== source);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/sound-effect.ts?");

/***/ }),

/***/ "./src/sound-manager.ts":
/*!******************************!*\
  !*** ./src/sound-manager.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundManager\": () => (/* binding */ SoundManager)\n/* harmony export */ });\n/* harmony import */ var _content_load_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content-load-list */ \"./src/content-load-list.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass SoundManager {\n    constructor(content) {\n        this.instances = new Map();\n        this.sounds = new Map();\n        this.content = content;\n    }\n    loadSound(path, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const eff = yield this.content.loadSoundEffect(path);\n            this.sounds.set(name, eff);\n        });\n    }\n    loadContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = [];\n            Object.entries(_content_load_list__WEBPACK_IMPORTED_MODULE_0__.soundSources).forEach(([name, source]) => promises.push(this.loadSound(source, name)));\n            yield Promise.all(promises);\n        });\n    }\n    getSound(name) {\n        const effect = this.sounds.get(name);\n        if (!effect)\n            throw new Error(`no sound was loaded with name ${name}`);\n        return effect;\n    }\n    play(name, volume, pitch, pan, loop) {\n        const soundEffect = this.getSound(name);\n        loop !== null && loop !== void 0 ? loop : (loop = false);\n        const inst = soundEffect.play(volume, pitch, pan, loop);\n        this.instances.set(soundEffect, inst);\n    }\n    playIfNotPlaying(name, volume, pitch, pan, loop) {\n        const soundEffect = this.getSound(name);\n        loop !== null && loop !== void 0 ? loop : (loop = false);\n        if (soundEffect.isPlaying) {\n            // Nope\n        }\n        else {\n            this.play(name, volume, pitch, pan, loop);\n        }\n    }\n    stopIfPlaying(name) {\n        const soundEffect = this.getSound(name);\n        soundEffect.stopIfPlaying();\n        if (this.instances.has(soundEffect))\n            this.instances.delete(soundEffect);\n    }\n    stopThemeMusic() {\n        this.stopIfPlaying('themeSong');\n    }\n    stopPlayMusic() {\n        this.stopIfPlaying('gamePlayMusic');\n    }\n    playGrowthNoise(playerSide, vel) {\n        const isLeft = playerSide === _types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Left;\n        if (vel < 0.0 && isLeft)\n            this.playIfNotPlaying('p1Shrinkage', 0.2, -vel, 0.0, true);\n        else if (vel > 0.0 && isLeft)\n            this.playIfNotPlaying('p1Growth', 0.2, -vel, 0.0, true);\n        else if (vel < 0.0 && !isLeft)\n            this.playIfNotPlaying('p2Shrinkage', 0.2, -vel, 0.0, true);\n        else if (vel > 0.0 && !isLeft)\n            this.playIfNotPlaying('p2Growth', 0.2, -vel, 0.0, true);\n    }\n    fadeOutSound(instance, dt, fadeOutSeconds) {\n        instance.fadeOut(fadeOutSeconds);\n    }\n    fadeGrowthNoise(playerSide, dt) {\n        if (playerSide === _types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Left) {\n            const sInstance = this.instances.get(this.getSound('p1Shrinkage'));\n            const gInstance = this.instances.get(this.getSound('p1Growth'));\n            if (sInstance === null || sInstance === void 0 ? void 0 : sInstance.effect.isPlaying)\n                this.fadeOutSound(sInstance, dt, 1.0);\n            if (gInstance === null || gInstance === void 0 ? void 0 : gInstance.effect.isPlaying)\n                this.fadeOutSound(gInstance, dt, 1.0);\n        }\n        else {\n            const sInstance = this.instances.get(this.getSound('p2Shrinkage'));\n            const gInstance = this.instances.get(this.getSound('p2Growth'));\n            if (sInstance === null || sInstance === void 0 ? void 0 : sInstance.effect.isPlaying)\n                this.fadeOutSound(sInstance, dt, 1.0);\n            if (gInstance === null || gInstance === void 0 ? void 0 : gInstance.effect.isPlaying)\n                this.fadeOutSound(gInstance, dt, 1.0);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/sound-manager.ts?");

/***/ }),

/***/ "./src/sprite-batch.ts":
/*!*****************************!*\
  !*** ./src/sprite-batch.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteBatch\": () => (/* binding */ SpriteBatch)\n/* harmony export */ });\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n\nconst textSizeCache = new Map();\nclass SpriteBatch {\n    constructor(canvasManager) {\n        this.canvasManager = canvasManager;\n    }\n    get ctx() {\n        return this.canvasManager.ctx;\n    }\n    /**\n     * draws a texture on the canvasManager, scaled appropriately. So none of the params\n     * here are dealing with pixels, but actual game units\n     */\n    drawTextureCentered(t, center, dim, rot, alpha) {\n        if (alpha <= 0)\n            return;\n        this.ctx.save();\n        // we need to rotate about center, so let's translate to center, rotate, translate back\n        const w = dim.w;\n        const h = dim.h;\n        const rotCenterX = w / 2;\n        const rotCenterY = h / 2;\n        this.ctx.translate(center.x, center.y);\n        this.ctx.transform(1, 0, 0, -1, 0, 0); // flip y-axis\n        if (rot)\n            this.ctx.rotate(-rot);\n        this.ctx.translate(-rotCenterX, -rotCenterY);\n        this.ctx.globalAlpha = alpha;\n        this.ctx.drawImage(t.img, 0, 0, w, h);\n        this.ctx.restore();\n    }\n    drawStringCentered(s, font, size, center, color, rot) {\n        // unfortunately the below single line should work but seems choppier. it would be nice, because\n        // the alternative, my calling `ctx.measureText()` is somewhat computational expensive\n        //this.drawStringUncentered(s, font, size, center, color, rot, {textAlign: 'center', textBaseline: 'middle'})\n        // so we do it manually\n        if (color.a === 0)\n            return;\n        this.ctx.save();\n        const pxCenter = this.canvasManager.canvasToPixelPos(center);\n        this.ctx.font = this.fontDescriptor(font, size);\n        let boxTm = textSizeCache.get(s);\n        if (!boxTm) {\n            boxTm = this.ctx.measureText(s);\n            textSizeCache.set(s, boxTm);\n        }\n        const boxWidth = boxTm.width;\n        const boxHeight = boxTm.actualBoundingBoxAscent + boxTm.actualBoundingBoxDescent;\n        this.ctx.resetTransform();\n        const rotCenterX2 = boxWidth / 2;\n        const rotCenterY2 = -boxHeight / 2;\n        this.ctx.translate(pxCenter.x, pxCenter.y);\n        this.ctx.rotate(rot !== null && rot !== void 0 ? rot : 0);\n        this.ctx.translate(-rotCenterX2, -rotCenterY2);\n        this.ctx.fillStyle = color.toHtmlRgb();\n        this.ctx.fillText(s, 0, 0);\n        this.ctx.restore();\n    }\n    drawStringUncentered(s, font, size, pos, color, rot, opts) {\n        opts !== null && opts !== void 0 ? opts : (opts = {});\n        if (color.a === 0)\n            return;\n        this.ctx.save();\n        const pxPos = this.canvasManager.canvasToPixelPos(pos);\n        this.ctx.font = this.fontDescriptor(font, size);\n        this.ctx.resetTransform();\n        this.ctx.translate(pxPos.x, pxPos.y);\n        this.ctx.rotate(rot !== null && rot !== void 0 ? rot : 0);\n        if (opts.textBaseline)\n            this.ctx.textBaseline = opts.textBaseline;\n        if (opts.textAlign)\n            this.ctx.textAlign = opts.textAlign;\n        this.ctx.fillStyle = color.toHtmlRgb();\n        this.ctx.fillText(s, 0, 0);\n        this.ctx.restore();\n    }\n    drawTextureInRect(t, rect, alpha) {\n        const w = rect.x2 - rect.x1;\n        const h = rect.y2 - rect.y1;\n        const center = { x: (rect.x1 + rect.x2) / 2, y: (rect.y1 + rect.y2) / 2 };\n        this.drawTextureCentered(t, center, { w, h }, 0, alpha);\n    }\n    drawScreenOverlay(color) {\n        this.ctx.save();\n        this.ctx.resetTransform();\n        this.ctx.fillStyle = color.toHtmlRgb();\n        this.ctx.fillRect(0, 0, this.canvasManager.width, this.canvasManager.height);\n        this.ctx.restore();\n    }\n    /**\n     * returns width and height object for the given texture,\n     * given a desired width passed in. basically just scales to aspectRatio.\n     * @param width\n     * @param texture2d\n     * @returns\n     */\n    autoDim(width, texture2d) {\n        return {\n            w: width,\n            h: (width * texture2d.height) / texture2d.width,\n        };\n    }\n    /**\n     * returns something like \"bold 12px 'nunito sans', sans-serif\"\n     * @param font - font definition\n     * @param size - the size in game coordinates; gets converted to pixels\n     * @returns string\n     */\n    fontDescriptor(font, size) {\n        const pixelWidth = this.canvasManager.pixelWidth(1);\n        const pxSize = size / pixelWidth;\n        const res = `${font.weight} ${pxSize.toFixed(4)}px \"${font.family}\", ${_tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fontFamilyFallback}`;\n        //console.log(`Got font descriptor \"${res}\"`)\n        return res;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/sprite-batch.ts?");

/***/ }),

/***/ "./src/tweakables.ts":
/*!***************************!*\
  !*** ./src/tweakables.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"./src/color.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\n\n//\n// TODO: extract all the garbage I hard-coded in game.ts into here\n//\nconst twoPlayerControls = {\n    p0: {\n        left: ['KeyA'],\n        right: ['KeyD'],\n        jump: ['KeyW'],\n        shrink: ['KeyQ'],\n        grow: ['KeyE'],\n    },\n    p1: {\n        left: ['KeyJ', 'ArrowLeft'],\n        right: ['KeyL', 'ArrowRight'],\n        jump: ['KeyI', 'ArrowUp'],\n        shrink: ['KeyU', 'Period'],\n        grow: ['KeyO', 'Slash'],\n    },\n};\n// allow any of the above for one player games\nconst p0Set = {\n    left: twoPlayerControls.p0.left.concat(twoPlayerControls.p1.left),\n    right: twoPlayerControls.p0.right.concat(twoPlayerControls.p1.right),\n    jump: twoPlayerControls.p0.jump.concat(twoPlayerControls.p1.jump),\n    shrink: twoPlayerControls.p0.shrink.concat(twoPlayerControls.p1.shrink),\n    grow: twoPlayerControls.p0.grow.concat(twoPlayerControls.p1.grow),\n};\nconst onePlayerControls = {\n    p0: p0Set,\n    p1: p0Set,\n};\n// THE GAME COORDINATE SYSTEM\n// The game is played on its own coordinate system, which is typical euclidean.\n// With the ground at y=0 and the net at x=0.\n// Also, positive Y is UP, like most math, but unlike most comptuer graphics\n// So if a ball is at (0.5, 0.5), that means it's to the right and up, relative to the net.\n//\n// rotations are counter-clockwise and in radians. As you'd expect!\n//\n// how far between the walls' edges (not their centers). In other words, this describes\n// the width of the playable area.\nconst courtWidth = 1.1;\nconst flowerDims = { w: 0.258, h: 1.0 };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    courtWidth,\n    twoPlayerControls,\n    onePlayerControls,\n    physics: {\n        ballPlayerElasticity: 0.95,\n        ballAngularFriction: 0.5,\n        ballFloorElasticity: 0.5,\n        maxAngVel: 100,\n        ballSpinElasticityOffFrictionPoints: 0.5,\n        ballSpinVelocityBumpOffFrictionPoints: 0.45,\n        ballOnBallFrictionSpin: 0.95,\n        ballOnBallFrictionBump: 0.5,\n        minRelSpeedToAllowBallSpins: 0.25,\n    },\n    input: {\n        triggerTolerance: 0.05,\n        triggerGrowthMult: 0.4,\n        thumbstickPush: 0.6, // how far stick has to go to be considered pushed like a dpad\n    },\n    display: {\n        zoomCenter: { x: 0, y: 0.3 },\n        zoomScale: {\n            min: 0.45,\n            start: 0.8,\n            max: 0.8,\n            springConstant: 0.5,\n            ballHeightMult: 1.05, // multiplies expected ball height by this to get zoom scale\n        },\n        scorecard: {\n            textOffset: { x: 0, y: 0 },\n        },\n    },\n    fpsSampleCount: 100,\n    ballPlayerLaunchTime: 1,\n    winningScore: 5,\n    gameGravity: { x: 0, y: -1.9 },\n    timeOnServeFloorDisappears: 0.15,\n    afterPointKeepMovingSec: 1,\n    afterPointFreezeSec: 0.01,\n    predictFutureEveryMs: 10,\n    physicsDtSec: 0.002,\n    redrawTargetMs: 4,\n    predictionLookaheadSec: 1.75,\n    predictionPhysicsDtSec: 0.004,\n    predictionStorageDtSec: 0.02,\n    thumbstickCenterTolerance: 0.05,\n    keyboardGrowthRate: 0.1,\n    fontFamilyFallback: \"'Courier New', Arial\",\n    net: {\n        center: { x: 0, y: 0.025 },\n        width: 0.08,\n        height: 0.055,\n    },\n    invisibleFloor: {\n        center: { x: 0, y: -0.5 },\n        width: courtWidth * 2,\n        height: 1,\n    },\n    leftWall: {\n        center: { x: -courtWidth / 2 - flowerDims.w / 2, y: 0.5 },\n        width: flowerDims.w,\n        height: flowerDims.h,\n    },\n    rightWall: {\n        center: { x: courtWidth / 2 + flowerDims.w / 2, y: 0.5 },\n        width: flowerDims.w,\n        height: flowerDims.h,\n    },\n    floorFront: {\n        yMax: 0, // draws below this line\n    },\n    floorBack: {\n        yMax: 0.0365,\n        yMin: -0.07,\n    },\n    ball: {\n        defaultSettings: {\n            mass: 0.1,\n            diameter: 0.08,\n            maxSpeed: 1.4,\n        },\n    },\n    cloud: {\n        num: 5,\n        minVel: { x: 0.01, y: -0.01 },\n        maxVel: { x: 0.07, y: 0.01 },\n    },\n    atmosphere: {\n        timeToTurnSunny: 2,\n        timeToTurnDark: 3,\n        maxSkies: 3,\n        skyTransitionMs: 1000,\n    },\n    moon: {\n        nightHeightFrac: 0.75,\n        widthFrac: 0.3,\n    },\n    proximityTolerance: 0.001,\n    player: {\n        growSpeed: 0.1,\n        minDiameter: 0.09,\n        maxDiameter: 0.175,\n        jumpSpeedAfterPoint: 1.85,\n        afterPointJumpDelay: 0.15,\n        eyes: {\n            // for drawing\n            leftOffset: { x: -0.113, y: 0.14 },\n            rightOffset: { x: 0.1195, y: 0.144 },\n            leftScale: 0.24 * 0.67,\n            rightScale: 0.28 * 0.67,\n            blinkScale: 0.1,\n            blinkEveryMs: 5000,\n            blinkDurationMs: 100,\n        },\n        defaultSettings: () => ({\n            maxVel: { x: 0.8, y: 1.2 },\n            diameter: 0.15,\n            mass: 3,\n            xSpringConstant: 30,\n            gravityMultiplier: 1.9,\n            targetXVel: 0,\n            species: _types__WEBPACK_IMPORTED_MODULE_1__.PlayerSpecies.Human,\n            ai: null,\n        }),\n    },\n    menu: {\n        bpm: 87,\n        cardWidth: 0.7,\n        cardWidthSelected: 1.0,\n        cardStackStart: { x: 0, y: 0.5 },\n        cardStackSpacing: { x: 0.2, y: 0.0 },\n        textOffsetFromCard: { x: 0, y: 0.4 },\n        afterChosenOffset: { x: 0.1, y: -0.1 },\n        coverColor: new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0, 0.3),\n        deselectedCardColor: new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0, 0.2),\n        cardBall1Pos: { x: 0.85, y: 0.73 },\n        cardBall2Pos: { x: 0.85, y: 0.58 },\n        lockReasonPos: { x: 0, y: -0.4 },\n        lockReasonColor: new _color__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 0.8),\n        cardBallSize: 0.08,\n        cardSizeBounce: 0.05,\n        cardRotationBounce: 0.03,\n        subtextOffset: { x: 0, y: -0.2 },\n        subtextRelSize: 0.4,\n        lockOverlayAlpha: 0.8,\n        statsPosition: { x: 0.5, y: -0.1 },\n        statsColorLeft: new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0.5, 1, 0, 0.5),\n        statsColorRight: new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0.5, 1, 0, 0.7),\n        statsColorRightBad: new _color__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0, 0.7),\n        statsFontSize: 0.035,\n        statsLineSpacing: 1.2,\n        statsRightColAdj: { x: 0.02, y: -0.0025 },\n        statsRightColFontMult: 1.1,\n        statsFastestWinFlames: [60, 45, 30, 15],\n    },\n    scoreCard: {\n        bounceVelocity: 2.5,\n        dampeningConstant: 1.5,\n        maxSizeMultiplier: 3.0,\n        minSizeMultiplier: 0.25,\n        sizeMultiplier: 1,\n        sizeVelocity: 0,\n        springConstant: 24.0,\n    },\n});\n\n\n//# sourceURL=webpack:///./src/tweakables.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameState\": () => (/* binding */ GameState),\n/* harmony export */   \"PlayerSide\": () => (/* binding */ PlayerSide),\n/* harmony export */   \"PlayerSpecies\": () => (/* binding */ PlayerSpecies)\n/* harmony export */ });\nvar PlayerSide;\n(function (PlayerSide) {\n    PlayerSide[\"Left\"] = \"left\";\n    PlayerSide[\"Right\"] = \"right\";\n})(PlayerSide || (PlayerSide = {}));\nvar PlayerSpecies;\n(function (PlayerSpecies) {\n    PlayerSpecies[\"Ai\"] = \"ai\";\n    PlayerSpecies[\"Human\"] = \"human\";\n})(PlayerSpecies || (PlayerSpecies = {}));\nvar GameState;\n(function (GameState) {\n    GameState[\"PreStart\"] = \"pre-start\";\n    GameState[\"Intro1\"] = \"intro1\";\n    GameState[\"Intro2\"] = \"intro2\";\n    GameState[\"Intro3\"] = \"intro3\";\n    GameState[\"MainMenu\"] = \"main-menu\";\n    GameState[\"PointScored\"] = \"point-scored\";\n    GameState[\"Victory\"] = \"victory\";\n    GameState[\"PreAction\"] = \"pre-action\";\n    GameState[\"Action\"] = \"action\";\n    GameState[\"Paused\"] = \"paused\";\n    GameState[\"AutoPaused\"] = \"auto-paused\";\n    GameState[\"PreExitMessage\"] = \"pre-exit-message\";\n    GameState[\"PreExitCredits\"] = \"pre-exit-credts\";\n    GameState[\"Exit\"] = \"exit\";\n})(GameState || (GameState = {}));\n\n\n\n//# sourceURL=webpack:///./src/types.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"aspectRatio\": () => (/* binding */ aspectRatio),\n/* harmony export */   \"randomByteHexString\": () => (/* binding */ randomByteHexString),\n/* harmony export */   \"sign\": () => (/* binding */ sign),\n/* harmony export */   \"timeout\": () => (/* binding */ timeout),\n/* harmony export */   \"vec\": () => (/* binding */ vec)\n/* harmony export */ });\nfunction timeout(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve();\n        }, ms);\n    });\n}\nfunction sign(n) {\n    if (n > 0)\n        return 1;\n    else if (n < 0)\n        return -1;\n    else\n        throw new Error(`0 (Nan, etc) is unsigned`);\n}\nconst vec = {\n    copy: (v) => ({ x: v.x, y: v.y }),\n    sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),\n    add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),\n    lenSq: (v) => v.x * v.x + v.y * v.y,\n    len: (v) => Math.sqrt(vec.lenSq(v)),\n    scale: (v, k) => ({ x: v.x * k, y: v.y * k }),\n    normalized: (v) => {\n        const len = vec.len(v);\n        return { x: v.x / len, y: v.y / len };\n    },\n    dotProduct: (v1, v2) => v1.x * v2.x + v1.y * v2.y,\n    zero: () => ({ x: 0, y: 0 }),\n    transform: (p, matrix) => {\n        const x = p.x * matrix.a + p.y * matrix.c + matrix.e;\n        const y = p.x * matrix.b + p.y * matrix.d + matrix.f;\n        return { x, y };\n    },\n    avg: (v1, v2) => ({\n        x: (v1.x + v2.x) / 2,\n        y: (v1.y + v2.y) / 2,\n    }),\n    rotated90Ccw: (v) => ({\n        x: -v.y,\n        y: v.x,\n    }),\n};\nfunction randomByteHexString(numBytes) {\n    return Array.from(crypto.getRandomValues(new Uint8Array(numBytes)))\n        .map((b) => b.toString(16).padStart(2, '0'))\n        .join('');\n}\nconst aspectRatio = (t) => t.width / t.height;\n\n\n\n//# sourceURL=webpack:///./src/utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;